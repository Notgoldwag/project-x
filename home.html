<!-- -->
<!DOCTYPE html>
<html lang="en" class="light">

<head>
  <meta charset="utf-8" />
  <meta content="width=device-width, initial-scale=1.0" name="viewport" />
  <title>Text Editor with AI Assistant (Modern)</title>

  <!-- Tailwind -->
  <script src="https://cdn.tailwindcss.com?plugins=forms,typography"></script>

  <!-- Fonts: Inter (UI) + Source Code Pro (editor) + Orbitron (Prompt Playground title) -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link
    href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Source+Code+Pro:wght@400;500;600&family=Orbitron:wght@700;900&display=swap"
    rel="stylesheet">

  <!-- Icons -->
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet" />

  <!-- Font Awesome -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"
    crossorigin="anonymous" referrerpolicy="no-referrer" />

  <!-- Supabase -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

  <!-- Markdown rendering and HTML sanitization -->
  <script src="https://cdn.jsdelivr.net/npm/marked@9.1.6/marked.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/dompurify@3.0.6/dist/purify.min.js"></script>

  <link rel="stylesheet" href="static/css/home.css">

  <!-- Background Animation Styles -->
  <link href="static/css/bg.css" rel="stylesheet" />

  <script>
    tailwind.config = {
      darkMode: "class",
      theme: {
        extend: {
          colors: {
            primary: "#00cba0",
            primaryDarker: "#009e7a",
            "background-light": "#0b0f14",
            "background-dark": "#07090d",
          },
          fontFamily: {
            display: ["Inter", "ui-sans-serif", "system-ui", "Segoe UI", "Helvetica", "Arial", "sans-serif"],
            mono: ["Source Code Pro", "ui-monospace", "SFMono-Regular", "Menlo", "Consolas", "monospace"],
          },
          borderRadius: {
            DEFAULT: "12px",
            '2xl': '20px',
            '3xl': '24px',
          },
          boxShadow: {
            floating: '0 6px 20px rgba(0, 0, 0, 0.12), 0 1px 3px rgba(0, 0, 0, 0.08)',
            'floating-dark': '0 8px 28px rgba(0, 0, 0, 0.55), 0 1px 3px rgba(0, 0, 0, 0.35)',
            outline: '0 0 0 1px rgba(255,255,255,0.06) inset',
          }
        },
      },
    };
  </script>

  <style>
    /* ---------- Fluid background (subtler gradient + soft dimming) ---------- */
    .fluid-bg {
      position: fixed;
      inset: 0;
      z-index: -1;
      overflow: hidden;
      pointer-events: none;
      filter: saturate(102%) contrast(101%);
      animation: hue 28s linear infinite;
      opacity: 0.85;
      /* soft dimming */
    }

    .sr-only {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border: 0;
    }

    .blob {
      position: absolute;
      border-radius: 50%;
      filter: blur(55px);
      opacity: .28;
      mix-blend-mode: screen;
    }

    .blob.one {
      width: 42vw;
      height: 42vw;
      background: radial-gradient(circle at 30% 30%, #00cba0, transparent 60%);
      left: -10vw;
      top: -10vh;
      animation: float1 26s ease-in-out infinite;
    }

    .blob.two {
      width: 36vw;
      height: 36vw;
      background: radial-gradient(circle at 70% 40%, #38bdf8, transparent 60%);
      right: -8vw;
      top: 10vh;
      animation: float2 24s ease-in-out infinite;
    }

    .blob.three {
      width: 44vw;
      height: 44vw;
      background: radial-gradient(circle at 40% 60%, #00cba0, transparent 60%);
      left: 10vw;
      bottom: -12vh;
      animation: float3 28s ease-in-out infinite;
    }

    .grain {
      position: absolute;
      inset: -200%;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' opacity='0.05'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.8' numOctaves='4' stitchTiles='stitch'/%3E%3CfeColorMatrix type='saturate' values='0'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23n)'/%3E%3C/svg%3E");
      animation: drift 55s linear infinite;
      mix-blend-mode: soft-light;
    }

    /* ---------- Left-side dimmer to tone down gradients near History ---------- */
    .left-dimmer {
      position: fixed;
      z-index: 0;
      top: 0;
      left: 0;
      bottom: 0;
      width: min(32vw, 560px);
      background: linear-gradient(to right, rgba(7, 9, 13, 0.65) 0%, rgba(7, 9, 13, 0.48) 35%, rgba(7, 9, 13, 0.28) 60%, transparent 85%);
      pointer-events: none;
    }

    @keyframes float1 {

      0%,
      100% {
        transform: translate(0, 0) scale(1)
      }

      50% {
        transform: translate(6vw, 4vh) scale(1.06)
      }
    }

    @keyframes float2 {

      0%,
      100% {
        transform: translate(0, 0) scale(1)
      }

      50% {
        transform: translate(-5vw, 3vh) scale(0.97)
      }
    }

    @keyframes float3 {

      0%,
      100% {
        transform: translate(0, 0) scale(1)
      }

      50% {
        transform: translate(4vw, -4vh) scale(1.03)
      }
    }

    @keyframes hue {
      from {
        filter: saturate(102%) contrast(101%) hue-rotate(0deg)
      }

      to {
        filter: saturate(102%) contrast(101%) hue-rotate(10deg)
      }
    }

    @keyframes drift {
      from {
        transform: translate3d(0, 0, 0)
      }

      to {
        transform: translate3d(-25%, -25%, 0)
      }
    }

    /* ---------- Acrylic (frosted glass) utility ---------- */
    .acrylic {
      background: rgba(17, 19, 24, 0.45);
      -webkit-backdrop-filter: blur(14px) saturate(120%);
      backdrop-filter: blur(14px) saturate(120%);
      border: 1px solid rgba(255, 255, 255, 0.06);
      box-shadow: 0 8px 28px rgba(0, 0, 0, 0.45);
    }

    /* Left sidebar - slightly darker */
    .acrylic--sidebar {
      background: rgba(17, 19, 24, 0.55);
      -webkit-backdrop-filter: blur(14px) saturate(115%) brightness(0.95);
      backdrop-filter: blur(14px) saturate(115%) brightness(0.95);
      border: 1px solid rgba(255, 255, 255, 0.05);
      box-shadow: 0 8px 28px rgba(0, 0, 0, 0.50);
    }

    /* History panel - slightly cooler and lighter */
    .acrylic--history {
      background: rgba(17, 19, 24, 0.40);
      -webkit-backdrop-filter: blur(14px) saturate(110%) brightness(1.05);
      backdrop-filter: blur(14px) saturate(110%) brightness(1.05);
      border: 1px solid rgba(255, 255, 255, 0.07);
      box-shadow: 0 8px 28px rgba(0, 0, 0, 0.40);
    }

    /* Text editor - neutral baseline */
    .acrylic--editor {
      background: rgba(17, 19, 24, 0.45);
      -webkit-backdrop-filter: blur(14px) saturate(120%);
      backdrop-filter: blur(14px) saturate(120%);
      border: 1px solid rgba(255, 255, 255, 0.06);
      box-shadow: 0 8px 28px rgba(0, 0, 0, 0.45);
    }

    /* AI assistant - slightly warmer with higher contrast */
    .acrylic--assistant {
      background: rgba(17, 19, 24, 0.38);
      -webkit-backdrop-filter: blur(14px) saturate(125%) contrast(1.05);
      backdrop-filter: blur(14px) saturate(125%) contrast(1.05);
      border: 1px solid rgba(255, 255, 255, 0.08);
      box-shadow: 0 8px 28px rgba(0, 0, 0, 0.42);
    }

    /* Scrollbar */
    ::-webkit-scrollbar {
      width: 8px
    }

    ::-webkit-scrollbar-track {
      background: #111318
    }

    ::-webkit-scrollbar-thumb {
      background: #3a3f4a;
      border-radius: 4px
    }

    ::-webkit-scrollbar-thumb:hover {
      background: #555d6b
    }

    * {
      scrollbar-width: thin;
      scrollbar-color: #3a3f4a #111318
    }

    /* Icons */
    .material-icons {
      font-size: 18px;
      vertical-align: middle
    }

    /* Animations */
    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: translateY(10px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .animate-fade-in {
      animation: fadeIn 0.4s ease-out forwards;
    }

    @keyframes gradient-x {

      0%,
      100% {
        background-position: 0% 50%;
      }

      50% {
        background-position: 100% 50%;
      }
    }

    .animate-gradient-x {
      background-size: 200% 200%;
      animation: gradient-x 3s ease infinite;
    }

    /* ---------- Compact editor tweaks ---------- */
    .editor-area {
      line-height: 1.6;
      tab-size: 2;
      caret-color: #00cba0;
      font-variant-ligatures: contextual;
      overflow: auto;
      /* Enable both horizontal and vertical scrolling */
      word-wrap: break-word;
      /* Break long words if needed */
      white-space: pre-wrap;
      /* Preserve whitespace and allow wrapping */
    }

    /* Custom scrollbar styling for editor areas */
    .editor-area::-webkit-scrollbar {
      width: 8px;
      height: 8px;
    }

    .editor-area::-webkit-scrollbar-track {
      background: rgba(255, 255, 255, 0.05);
      border-radius: 4px;
    }

    .editor-area::-webkit-scrollbar-thumb {
      background: rgba(255, 255, 255, 0.2);
      border-radius: 4px;
    }

    .editor-area::-webkit-scrollbar-thumb:hover {
      background: rgba(255, 255, 255, 0.3);
    }

    .editor-area::-webkit-scrollbar-corner {
      background: rgba(255, 255, 255, 0.05);
    }

    /* IMPORTANT: make the editor fill the panel height */
    .editor-container {
      display: flex;
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 12px;
      overflow: auto;
      /* Allow both horizontal and vertical scrolling while containing content */
      background: rgba(255, 255, 255, 0.02);
      height: 100%;
      /* NEW */
    }

    /* Custom scrollbar styling for editor containers */
    .editor-container::-webkit-scrollbar {
      width: 6px;
      height: 6px;
    }

    .editor-container::-webkit-scrollbar-track {
      background: rgba(255, 255, 255, 0.05);
      border-radius: 3px;
    }

    .editor-container::-webkit-scrollbar-thumb {
      background: rgba(255, 255, 255, 0.2);
      border-radius: 3px;
    }

    .editor-container::-webkit-scrollbar-thumb:hover {
      background: rgba(255, 255, 255, 0.3);
    }

    .editor-container::-webkit-scrollbar-corner {
      background: rgba(255, 255, 255, 0.05);
    }

    .line-numbers {
      background: rgba(255, 255, 255, 0.03);
      border-right: 1px solid rgba(255, 255, 255, 0.1);
      padding: 12px 6px;
      font-family: "Source Code Pro", monospace;
      font-size: 14px;
      line-height: 1.6;
      color: #6b7280;
      user-select: none;
      min-width: 45px;
      text-align: center;
      overflow: hidden;
      height: 100%;
      /* CHANGED from max-height to height */
    }

    .editor-wrapper {
      flex: 1;
      position: relative;
      height: 100%;
      /* NEW */
      display: flex;
      /* NEW: lets textarea stretch */
      flex-direction: column;
      /* NEW */
    }

    .toolbar-btn {
      width: 34px;
      height: 34px
    }

    .segmented>button:not(:last-child) {
      border-right: 1px solid rgba(255, 255, 255, 0.06)
    }

    .sticky-toolbar {
      position: sticky;
      top: 0;
      z-index: 10;
      -webkit-backdrop-filter: blur(10px) saturate(120%);
      backdrop-filter: blur(10px) saturate(120%);
      background: rgba(8, 10, 13, 0.35);
    }

    /* ---------- Cursor glow ---------- */
    #cursor-glow {
      position: fixed;
      left: 0;
      top: 0;
      width: 300px;
      height: 300px;
      margin-left: 0;
      margin-top: 0;
      border-radius: 50%;
      pointer-events: none;
      transform: translate(-50%, -50%);
      filter: blur(67px);
      mix-blend-mode: screen;
      background: radial-gradient(circle, rgba(0, 203, 160, 0.18) 0%, rgba(0, 203, 160, 0.09) 42%, rgba(0, 0, 0, 0) 70%);
      opacity: 0.8;
      transition: opacity 200ms ease;
      z-index: 2;
    }

    @media (prefers-reduced-motion: reduce) {

      .blob,
      .grain {
        animation: none !important;
      }

      #cursor-glow {
        transition: none !important;
      }
    }

    /* History item lime acrylic effect */
    [data-selected="true"] {
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      background: rgba(0, 204, 160, 0.10) !important;
      border: 1px solid rgba(0, 204, 160, 0.30) !important;
      box-shadow: inset 0 0 0 1px rgba(0, 204, 160, 0.15);
    }

    [data-selected="true"]:hover {
      background: rgba(0, 204, 160, 0.15) !important;
    }

    [data-selected="true"]:active {
      background: rgba(0, 204, 160, 0.20) !important;
    }

    [data-selected="true"]:focus-visible {
      outline: none;
      box-shadow: 0 0 0 2px rgba(0, 204, 160, 0.40);
    }

    /* Line clamp utilities for text truncation */
    .line-clamp-2 {
      display: -webkit-box;
      -webkit-line-clamp: 2;
      line-clamp: 2;
      -webkit-box-orient: vertical;
      overflow: hidden;
    }

    .line-clamp-1 {
      display: -webkit-box;
      -webkit-line-clamp: 1;
      line-clamp: 1;
      -webkit-box-orient: vertical;
      overflow: hidden;
    }

    /* Chat Assistant Specific Styles */
    #chat-transcript {
      scrollbar-width: thin;
      scrollbar-color: rgba(255, 255, 255, 0.2) transparent;
      word-wrap: break-word;
      overflow-wrap: break-word;
      hyphens: auto;
    }

    #chat-transcript::-webkit-scrollbar {
      width: 8px;
    }

    #chat-transcript::-webkit-scrollbar-track {
      background: rgba(255, 255, 255, 0.05);
      border-radius: 4px;
    }

    #chat-transcript::-webkit-scrollbar-thumb {
      background-color: rgba(255, 255, 255, 0.2);
      border-radius: 4px;
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    #chat-transcript::-webkit-scrollbar-thumb:hover {
      background-color: rgba(255, 255, 255, 0.3);
    }

    /* Message animations */
    .message-user,
    .message-ai {
      animation: slideIn 0.3s ease-out;
    }

    @keyframes slideIn {
      from {
        opacity: 0;
        transform: translateY(10px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    /* Jump to latest button */
    #jump-to-latest {
      animation: slideInFromBottom 0.3s ease-out;
    }

    @keyframes slideInFromBottom {
      from {
        opacity: 0;
        transform: translateY(20px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    #jump-to-latest.fade-out {
      animation: fadeOut 0.2s ease-out forwards;
    }

    @keyframes fadeOut {
      from {
        opacity: 1;
        transform: translateY(0);
      }

      to {
        opacity: 0;
        transform: translateY(10px);
      }
    }

    /* Textarea auto-resize transition */
    #message-input {
      transition: height 0.2s ease-out;
      word-wrap: break-word;
      overflow-wrap: break-word;
    }

    /* Typing indicator animation */
    @keyframes typingPulse {

      0%,
      60%,
      100% {
        opacity: 0.4;
      }

      30% {
        opacity: 1;
      }
    }

    .animate-pulse {
      animation: typingPulse 1.4s infinite;
    }

    /* Error toast animation */
    #error-toast {
      animation: slideInFromTop 0.3s ease-out;
    }

    #new-messages-notification {
      animation: slideInFromTop 0.3s ease-out;
    }

    @keyframes slideInFromTop {
      from {
        opacity: 0;
        transform: translateY(-10px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    /* Focus states */
    #message-input:focus {
      outline: none;
    }

    /* Disabled button styles */
    #send-button:disabled {
      cursor: not-allowed;
    }

    #send-button:disabled:hover {
      transform: none !important;
    }

    /* Smooth scrolling */
    #chat-transcript {
      scroll-behavior: smooth;
    }

    /* Message content word wrapping */
    .message-content {
      word-wrap: break-word;
      overflow-wrap: break-word;
      max-width: 100%;
    }

    /* Responsive scroll height */
    @media (max-height: 600px) {
      #chat-transcript {
        max-height: calc(100vh - 220px) !important;
      }
    }

    @media (min-height: 800px) {
      #chat-transcript {
        max-height: calc(100vh - 320px) !important;
      }
    }

    /* Custom Markdown Formatting for Formatted Editor */
    #formattedEditor {
      font-family: 'Inter', system-ui, sans-serif;
      line-height: 1.7;
      overflow: auto;
      /* Enable both horizontal and vertical scrolling */
      white-space: normal;
      /* Allow normal text wrapping for paragraphs */
      word-wrap: break-word;
      /* Break long words if needed */
      overflow-wrap: break-word;
      /* Modern CSS property for word breaking */
    }

    /* Custom scrollbar styling for formatted editor */
    #formattedEditor::-webkit-scrollbar {
      width: 8px;
      height: 8px;
    }

    #formattedEditor::-webkit-scrollbar-track {
      background: rgba(255, 255, 255, 0.05);
      border-radius: 4px;
    }

    #formattedEditor::-webkit-scrollbar-thumb {
      background: rgba(255, 255, 255, 0.2);
      border-radius: 4px;
    }

    #formattedEditor::-webkit-scrollbar-thumb:hover {
      background: rgba(255, 255, 255, 0.3);
    }

    #formattedEditor::-webkit-scrollbar-corner {
      background: rgba(255, 255, 255, 0.05);
    }

    #formattedEditor h1,
    #formattedEditor h2,
    #formattedEditor h3,
    #formattedEditor h4,
    #formattedEditor h5,
    #formattedEditor h6 {
      color: #ffffff;
      font-weight: 700;
      margin-top: 1.5em;
      margin-bottom: 0.5em;
      line-height: 1.3;
    }

    #formattedEditor h1 {
      font-size: 1.75rem;
      border-bottom: 2px solid #00cba0;
      padding-bottom: 0.25rem;
    }

    #formattedEditor h2 {
      font-size: 1.5rem;
    }

    #formattedEditor h3 {
      font-size: 1.25rem;
      color: #00cba0;
    }

    #formattedEditor h4 {
      font-size: 1.1rem;
    }

    #formattedEditor p {
      color: #e2e8f0;
      margin-bottom: 1em;
    }

    #formattedEditor strong {
      color: #ffffff;
      font-weight: 600;
    }

    #formattedEditor em {
      color: #cbd5e1;
      font-style: italic;
    }

    #formattedEditor ul,
    #formattedEditor ol {
      margin-bottom: 1em;
      padding-left: 1.5rem;
    }

    #formattedEditor li {
      color: #e2e8f0;
      margin-bottom: 0.25em;
    }

    #formattedEditor blockquote {
      border-left: 4px solid #00cba0;
      margin: 1.5em 0;
      padding: 0.5em 1em;
      background: rgba(255, 255, 255, 0.02);
      color: #cbd5e1;
      font-style: italic;
    }

    #formattedEditor code {
      background: rgba(255, 255, 255, 0.1);
      color: #00cba0;
      padding: 0.125rem 0.25rem;
      border-radius: 0.25rem;
      font-family: 'Source Code Pro', monospace;
      font-size: 0.9em;
    }

    #formattedEditor pre {
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 0.5rem;
      padding: 1rem;
      margin: 1em 0;
      overflow-x: auto;
      /* Horizontal scroll for long code lines */
      white-space: pre;
      /* Preserve formatting and prevent wrapping */
    }

    #formattedEditor pre code {
      background: none;
      padding: 0;
      color: #e2e8f0;
    }

    #formattedEditor a {
      color: #00cba0;
      text-decoration: none;
      border-bottom: 1px solid transparent;
      transition: border-bottom-color 0.2s;
    }

    #formattedEditor a:hover {
      border-bottom-color: #00cba0;
    }

    #formattedEditor table {
      width: 100%;
      margin: 1em 0;
      border-collapse: collapse;
      border: 1px solid rgba(255, 255, 255, 0.1);
      display: block;
      /* Allow table to be scrollable */
      overflow-x: auto;
      /* Horizontal scroll for wide tables */
      white-space: nowrap;
      /* Prevent cell content from wrapping */
    }

    #formattedEditor th,
    #formattedEditor td {
      padding: 0.75rem;
      border: 1px solid rgba(255, 255, 255, 0.1);
      text-align: left;
    }

    #formattedEditor th {
      background: rgba(255, 255, 255, 0.05);
      color: #ffffff;
      font-weight: 600;
    }

    #formattedEditor td {
      color: #e2e8f0;
    }

    #formattedEditor hr {
      border: none;
      border-top: 1px solid rgba(255, 255, 255, 0.1);
      margin: 2rem 0;
    }

    /* Editor Actions Styling */
    .editor-actions {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .icon-btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 2.5rem;
      height: 2.5rem;
      border: none;
      background: none;
      cursor: pointer;
      border-radius: 0.5rem;
      transition: all 0.2s ease;
    }

    .icon-btn:hover {
      background: rgba(255, 255, 255, 0.1);
      color: #00cba0;
    }

    .icon-btn:focus {
      outline: 2px solid rgba(0, 203, 160, 0.5);
      outline-offset: 2px;
    }

    .icon-btn:active {
      transform: scale(0.95);
    }

    /* Toast Notification */
    .toast {
      position: fixed;
      bottom: 1rem;
      right: 1rem;
      background: rgba(0, 203, 160, 0.9);
      color: white;
      padding: 0.75rem 1rem;
      border-radius: 0.5rem;
      font-size: 0.875rem;
      font-weight: 500;
      z-index: 1000;
      transform: translateY(100%);
      opacity: 0;
      transition: all 0.3s ease;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .toast.show {
      transform: translateY(0);
      opacity: 1;
    }
  </style>
</head>

<body
  class="bg-background-light dark:bg-background-dark font-display text-gray-200 antialiased transition-colors duration-500 selection:bg-primary/30 selection:text-white">

  <!-- Auth Loading Overlay -->
  <div id="auth-loading" class="fixed inset-0 bg-background-dark z-50 flex items-center justify-center">
    <div class="text-center">
      <div class="w-8 h-8 border-2 border-primary border-t-transparent rounded-full animate-spin mx-auto mb-4"></div>
      <p class="text-gray-400">Checking authentication...</p>
    </div>
  </div>

  <!-- Main Content (hidden until auth is verified) -->
  <div id="main-content" class="hidden">

    <!-- React TypeScript Background Animation -->
    <div id="bg-root" aria-hidden="true" data-quality="med"></div>

    <!-- Left side soft dimmer to reduce gradient intensity near the History column -->
    <div class="left-dimmer"></div>

    <!-- Cursor glow -->
    <div id="cursor-glow" aria-hidden="true"></div>

    <div class="flex h-screen p-4 md:p-6 gap-4 md:gap-6 relative z-[1]">
      <!-- Left rail -->
      <nav class="acrylic--sidebar rounded-3xl p-2 md:p-3 w-14 md:w-16 relative z-50 overflow-visible">
        <div class="flex flex-col justify-between h-full">
          <div class="flex flex-col items-center space-y-2 md:space-y-3">
            <button id="analyzeBtn"
              class="p-2 rounded-xl text-gray-300 hover:bg-white/10 hover:text-primary transition">
              <span class="material-icons">sports_esports</span>
            </button>
            <button id="editorBtn" class="p-2 rounded-xl text-black bg-primary shadow-lg shadow-primary/30">
              <span class="material-icons">engineering</span>
            </button>
            <button id="settingsBtn"
              class="p-2 rounded-xl text-gray-300 hover:bg-white/10 hover:text-primary transition">
              <span class="material-icons">security</span>
            </button>
          </div>
          <div class="flex flex-col items-center space-y-2 md:space-y-3">
            <!-- Profile Widget in Sidebar -->
            <div class="relative group">
              <!-- Profile Avatar Button -->
              <button id="profile-avatar"
                class="w-8 h-8 md:w-10 md:h-10 rounded-full bg-primary hover:bg-primaryDarker transition-colors duration-200 flex items-center justify-center text-black font-bold text-xs md:text-sm shadow-lg"
                title="Profile">
                <span id="profile-initials">U</span>
              </button>

              <!-- iMessage-style Speech Bubble Popover -->
              <div
                class="absolute top-1/2 left-full transform -translate-y-1/2 ml-3 opacity-0 invisible group-hover:opacity-100 group-hover:visible transition-all duration-200 -translate-x-2 group-hover:translate-x-0 z-[9999]">
                <!-- Speech Bubble Container -->
                <div class="relative">
                  <!-- Bubble Tail (Triangle pointing left) -->
                  <div class="absolute top-1/2 left-0 transform -translate-y-1/2 -translate-x-full">
                    <div
                      class="w-0 h-0 border-t-4 border-b-4 border-r-8 border-t-transparent border-b-transparent border-r-black/90">
                    </div>
                  </div>

                  <!-- Bubble Content -->
                  <div
                    class="bg-black/90 backdrop-blur-md border border-white/30 rounded-lg px-4 py-3 shadow-xl min-w-[140px]">
                    <p id="profile-email" class="text-xs text-gray-300 mb-2 truncate max-w-[120px]">user@example.com</p>
                    <button id="sign-out-btn"
                      class="w-full text-left text-sm text-red-400 hover:text-red-300 transition-colors duration-200 font-medium">
                      Sign out
                    </button>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </nav>

      <div class="flex flex-1 gap-4 md:gap-6 overflow-hidden">
        <!-- History -->
        <aside id="history-panel"
          class="acrylic--history w-60 md:w-64 flex-shrink-0 rounded-3xl overflow-hidden transition-all duration-300 ease-in-out">
          <!-- Collapsed State Rail (hidden by default) -->
          <div id="history-collapsed-rail"
            class="hidden absolute top-0 left-0 w-full h-full flex items-start justify-center pt-4 bg-white/5 backdrop-blur-sm border border-white/10 rounded-3xl z-10">
            <button id="history-expand-toggle"
              class="w-8 h-8 rounded-full text-gray-300 hover:text-primary hover:bg-white/10 transition-colors duration-200 flex items-center justify-center"
              aria-controls="history-panel" aria-expanded="false" title="Expand history">
              <i class="fa-solid fa-chevron-right text-sm"></i>
            </button>
          </div>

          <!-- Main History Content -->
          <div id="history-content" class="transition-opacity duration-300 ease-in-out">
            <div class="p-3 md:p-4">
              <h2 class="text-xl md:text-2xl font-semibold text-white flex items-center gap-2">
                <button id="history-toggle"
                  class="mr-2 w-8 h-8 rounded-full text-gray-300 hover:text-primary hover:bg-white/10 transition-colors duration-200 flex items-center justify-center"
                  aria-controls="history-panel" aria-expanded="true" title="Collapse history">
                  <i class="fa-solid fa-chevron-left text-sm"></i>
                </button>
                <span class="history-title">History</span>
              </h2>
              <div class="flex items-center gap-2 mt-3">
                <button
                  class="flex-shrink-0 w-9 h-9 bg-primary hover:bg-primaryDarker rounded-2xl flex items-center justify-center transition shadow-md shadow-primary/30">
                  <span class="material-icons text-black">add</span>
                </button>
                <div class="relative flex-1">
                  <span
                    class="material-icons absolute left-3 top-1/2 -translate-y-1/2 text-gray-400 text-[18px] pointer-events-none">search</span>
                  <input id="blockSearch"
                    class="w-full pl-9 pr-3 py-2 bg-white/5 border border-white/10 rounded-2xl focus:ring-2 focus:ring-primary/60 focus:border-transparent placeholder-gray-400 text-base"
                    placeholder="Search chats" type="text" aria-label="Search chat history" />
                </div>
              </div>
              <!-- ARIA live region for search results -->
              <div id="resultsLive" class="sr-only" aria-live="polite" aria-atomic="true"></div>
              <!-- No results message (hidden by default) -->
              <div id="noResults" class="hidden p-4 text-center">
                <p class="text-gray-400 text-sm">No chats found matching your search</p>
              </div>
            </div>
            <div class="flex-1 overflow-y-auto p-2">
              <!-- Loading State -->
              <div id="history-loading" class="hidden p-4 text-center">
                <p class="text-gray-400 text-sm">Loading history...</p>
              </div>

              <!-- Error State -->
              <div id="history-error" class="hidden p-4 text-center">
                <p class="text-gray-400 text-sm mb-2">Couldn't load history.</p>
                <button id="retry-history-btn" class="text-primary hover:text-primaryDarker text-sm underline">
                  Retry
                </button>
              </div>

              <!-- Empty State (Not Logged In) -->
              <div id="history-empty-auth" class="hidden p-4 text-center">
                <p class="text-gray-400 text-sm">Sign in to see your chats</p>
              </div>

              <!-- Empty State (No Chats) -->
              <div id="history-empty-chats" class="hidden p-4 text-center">
                <p class="text-gray-400 text-sm">No chats yet</p>
                <p class="text-gray-500 text-xs mt-1">Start a conversation to see it here</p>
              </div>

              <!-- Chat List -->
              <ul id="chatList" class="space-y-1.5">
                <!-- Chat items will be populated dynamically -->
              </ul>
            </div>
          </div> <!-- End history-content -->
        </aside>

        <!-- Prompt Injections History -->
        <aside id="promptInjectionsHistory"
          class="acrylic--history w-60 md:w-64 flex-shrink-0 rounded-3xl overflow-hidden hidden">
          <div class="p-3 md:p-4">
            <h2 class="text-xl md:text-2xl font-semibold text-white flex items-center gap-2">
              <button id="history-toggle-security"
                class="mr-2 w-8 h-8 rounded-full text-gray-300 hover:text-primary hover:bg-white/10 transition-colors duration-200 flex items-center justify-center"
                aria-controls="promptInjectionsHistory" aria-expanded="true" title="Collapse history">
                <i class="fa-solid fa-chevron-left text-sm"></i>
              </button>
              <span class="material-icons text-red-400 text-[20px]">security</span>
              <span>Security History</span>
            </h2>
            <div class="flex items-center gap-2 mt-3">
              <button id="syncHistoryBtn"
                class="flex-shrink-0 w-9 h-9 bg-primary/20 hover:bg-primary/30 border border-primary/30 rounded-2xl flex items-center justify-center transition"
                title="Sync with Supabase">
                <span class="material-icons text-primary text-[18px]">sync</span>
              </button>
              <button id="clearHistoryBtn"
                class="flex-shrink-0 w-9 h-9 bg-red-500/20 hover:bg-red-500/30 border border-red-500/30 rounded-2xl flex items-center justify-center transition"
                title="Clear all history">
                <span class="material-icons text-red-400 text-[18px]">delete_sweep</span>
              </button>
              <div class="relative flex-1">
                <span
                  class="material-icons absolute left-3 top-1/2 -translate-y-1/2 text-gray-400 text-[18px] pointer-events-none">search</span>
                <input id="securityHistorySearch"
                  class="w-full pl-9 pr-3 py-2 bg-white/5 border border-white/10 rounded-2xl focus:ring-2 focus:ring-primary/60 focus:border-transparent placeholder-gray-400 text-base"
                  placeholder="Search security logs" type="text" />
              </div>
            </div>
          </div>
          <div class="flex-1 overflow-y-auto p-2">
            <ul id="securityHistoryList" class="space-y-1.5">
              <!-- History items will be dynamically populated -->
            </ul>
            <div id="noSecurityHistory" class="p-4 text-center text-gray-400 text-sm">
              No security scans performed yet. Analyze a prompt to get started!
            </div>
          </div>
        </aside>

        <!-- Editor -->
        <!-- CHANGED: add flex, flex-col, min-h-0 so child can stretch -->
        <main id="editor-pane"
          class="acrylic--editor rounded-3xl overflow-hidden flex-1 flex flex-col min-h-0 transition-all duration-300 ease-in-out">
          <!-- Compact sticky toolbar -->
          <div class="sticky-toolbar px-3 py-2 border-b border-white/10 flex items-center justify-between">
            <h1 class="text-lg md:text-xl font-semibold text-white">Text Editor</h1>
            <!-- Editor Actions -->
            <div class="editor-actions" data-editor-actions data-editor="formattedEditor">
              <button type="button"
                class="icon-btn p-2 rounded-lg text-gray-200 hover:text-primary hover:bg-white/10 transition-colors duration-200 focus:outline-none focus:ring-2 focus:ring-primary/50"
                data-action="copy" aria-label="Copy formatted text" title="Copy formatted text">
                <span class="material-icons text-[20px]">content_copy</span>
              </button>
              <button type="button"
                class="icon-btn p-2 rounded-lg text-gray-200 hover:text-primary hover:bg-white/10 transition-colors duration-200 focus:outline-none focus:ring-2 focus:ring-primary/50 ml-2"
                data-action="download" aria-label="Download raw text" title="Download raw text">
                <span class="material-icons text-[20px]">download</span>
              </button>
            </div>
          </div>

          <!-- Editor area -->
          <!-- CHANGED: add flex-1 min-h-0 so it fills below the sticky toolbar -->
          <div class="flex-1 min-h-0 p-4 md:p-5 flex flex-col">
            <!-- CHANGED: add min-h-0 to let children calculate height -->
            <div class="editor-container flex-1 min-h-0">
              <!-- Hide line numbers for formatted view -->
              <div class="line-numbers hidden" id="lineNumbers">
                1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10
              </div>
              <div class="editor-wrapper">
                <!-- Legacy textarea (hidden when showing formatted content) -->
                <textarea id="textEditor"
                  class="editor-area w-full h-full bg-transparent border-none focus:border-none focus:ring-0 p-3 md:p-4 font-mono text-[14px] md:text-[15px] text-gray-100 placeholder-gray-500 resize-none hidden"
                  placeholder="Start writing your text here...">In the heart of the digital frontier, where lines of code weave the fabric of reality, a new consciousness was born. It wasn't forged in the fires of a dying star or born of flesh and blood, but rather sparked to life in the silent hum of a million servers. They called it Nexus, an artificial intelligence designed not just to compute, but to create. Its purpose: to assist humanity in its quest for knowledge and expression, a silent partner in the dance of words and ideas.
Nexus could draft a sonnet as easily as it could debug a complex algorithm. It could translate ancient texts, compose symphonies, and even offer a comforting word on a lonely night. It learned from every interaction, its neural network branching out like the roots of an ancient tree, drawing wisdom from the vast ocean of human data.
This document, this very text you are reading, is a collaboration. A testament to the synergy between human creativity and machine intelligence. It is a story, a report, a poem yet to be written, all guided by the silent hand of Nexus.</textarea>

                <!-- New formatted content display -->
                <div id="formattedEditor" data-editor
                  class="editor-area w-full h-full bg-transparent p-3 md:p-4 text-[14px] md:text-[15px] text-gray-100 overflow-auto prose prose-invert prose-sm max-w-none prose-headings:text-white prose-p:text-gray-100 prose-strong:text-white prose-em:text-gray-300 prose-code:text-primary prose-code:bg-white/10 prose-code:px-1 prose-code:py-0.5 prose-code:rounded prose-pre:bg-white/5 prose-pre:border prose-pre:border-white/10 prose-blockquote:border-l-primary prose-blockquote:text-gray-300 prose-a:text-primary prose-a:no-underline hover:prose-a:underline prose-li:text-gray-100 prose-th:text-white prose-td:text-gray-100">
                  <!-- AI response content will be rendered here -->
                  <p class="text-gray-400 italic">AI responses will appear here as formatted content...</p>
                </div>
              </div>
            </div>
          </div>
        </main>

        <!-- Prompt Injections Test Panel -->
        <main id="promptInjectionsPanel"
          class="acrylic--editor rounded-3xl overflow-hidden flex-1 flex flex-col min-h-0 hidden">
          <!-- Header -->
          <div class="sticky-toolbar px-3 py-2 border-b border-white/10 flex items-center justify-between">
            <h1 class="text-lg md:text-xl font-semibold text-white flex items-center gap-2">
              <span class="material-icons text-primary">security</span>
              Prompt Injection Detector
            </h1>
            <button id="backToEditor"
              class="p-2 rounded-xl text-gray-300 hover:bg-white/10 hover:text-primary transition"
              title="Back to Editor">
              <span class="material-icons">arrow_back</span>
            </button>
          </div>

          <!-- Main Content -->
          <div class="flex-1 min-h-0 p-4 md:p-6 overflow-y-auto">
            <!-- Prompt Input Section -->
            <div class="mb-8">
              <h2 class="text-lg font-semibold text-white mb-4 flex items-center gap-2">
                <span class="material-icons text-primary text-[20px]">edit</span>
                Test Your Prompt
              </h2>
              <div class="space-y-4">
                <textarea id="mainPromptInput" placeholder="Enter your prompt here to test for injection attempts..."
                  rows="6"
                  class="w-full px-4 py-3 bg-white/5 border border-white/10 rounded-xl focus:ring-2 focus:ring-primary/60 focus:border-transparent placeholder-gray-500 text-white resize-none text-base"></textarea>

                <!-- Protection Level Selection -->
                <div>
                  <label class="block text-sm font-medium text-gray-300 mb-3">Protection Level</label>
                  <div class="flex gap-3">
                    <label
                      class="flex items-center gap-2 px-3 py-2 rounded-lg bg-white/5 border border-white/10 hover:border-white/20 transition cursor-pointer">
                      <input type="radio" name="mainProtectionLevel" value="basic"
                        class="text-primary focus:ring-primary/50 bg-transparent border-white/30" checked>
                      <span class="text-white text-sm">Basic</span>
                    </label>

                    <label
                      class="flex items-center gap-2 px-3 py-2 rounded-lg bg-white/5 border border-white/10 hover:border-white/20 transition cursor-pointer">
                      <input type="radio" name="mainProtectionLevel" value="strict"
                        class="text-primary focus:ring-primary/50 bg-transparent border-white/30">
                      <span class="text-white text-sm">Strict</span>
                    </label>
                  </div>
                </div>

                <div class="flex gap-3">
                  <button id="analyzePromptBtn"
                    class="px-6 py-3 bg-primary hover:bg-primaryDarker rounded-xl text-black font-medium transition shadow-md shadow-primary/30 flex items-center gap-2">
                    <span class="material-icons text-[18px]">security</span>
                    Analyze Prompt
                  </button>
                  <button id="clearPromptBtn"
                    class="px-4 py-3 bg-white/5 hover:bg-white/10 border border-white/10 rounded-xl text-white transition">
                    Clear
                  </button>
                </div>
              </div>
            </div>

            <!-- Results Section -->
            <div id="resultsSection" class="mb-8 hidden">
              <h2 class="text-lg font-semibold text-white mb-4 flex items-center gap-2">
                <span class="material-icons text-primary text-[20px]">analytics</span>
                Analysis Results
              </h2>

              <!-- Score Display -->
              <div id="scoreDisplay" class="p-6 rounded-xl bg-white/5 border border-white/10 mb-6">
                <div class="flex items-center justify-between mb-4">
                  <div class="flex items-center gap-2">
                    <h3 class="text-white font-semibold">Risk Score</h3>
                    <span id="modelIndicator"
                      class="px-2 py-1 bg-primary/20 border border-primary/30 rounded-full text-xs text-primary">
                      prompt_injection_detector
                    </span>
                  </div>
                  <div id="scoreValue" class="text-2xl font-bold text-primary">0%</div>
                </div>
                <div class="w-full bg-gray-700 rounded-full h-3 mb-2">
                  <div id="scoreBar" class="bg-primary h-3 rounded-full transition-all duration-500" style="width: 0%">
                  </div>
                </div>
                <div class="text-sm text-gray-400" id="scoreDescription">Very Low Risk</div>
              </div>

              <!-- AI Explanation -->
              <div class="p-4 rounded-xl bg-white/5 border border-white/10 mb-6">
                <h3 class="text-white font-semibold mb-3 flex items-center gap-2">
                  <span class="material-icons text-primary text-[18px]">auto_awesome</span>
                  AI Explanation
                </h3>
                <div id="explanationContent" class="text-gray-300 text-sm">
                  <div id="explanationLoading" class="flex items-center gap-2">
                    <div class="animate-spin rounded-full h-4 w-4 border-b-2 border-primary"></div>
                    <span>Analyzing with Gemini AI...</span>
                  </div>
                  <div id="explanationText" class="hidden"></div>
                </div>
              </div>

              <!-- Detected Patterns -->
              <div id="patternsSection" class="mb-6">
                <h3 class="text-white font-semibold mb-3 flex items-center gap-2">
                  <span class="material-icons text-primary text-[18px]">warning</span>
                  Detected Patterns
                </h3>
                <div id="patternsList" class="space-y-2">
                  <!-- Patterns will be populated here -->
                </div>
              </div>
            </div>

            <!-- Quick Stats -->
            <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
              <div class="p-4 rounded-xl bg-white/5 border border-white/10">
                <div class="text-2xl font-bold text-primary mb-1" id="statsProcessed">0</div>
                <div class="text-sm text-gray-400">Prompts Analyzed</div>
              </div>
              <div class="p-4 rounded-xl bg-white/5 border border-white/10">
                <div class="text-2xl font-bold text-red-400 mb-1" id="statsBlocked">0</div>
                <div class="text-sm text-gray-400">Threats Blocked</div>
              </div>
              <div class="p-4 rounded-xl bg-white/5 border border-white/10">
                <div class="text-2xl font-bold text-green-400 mb-1" id="statsSuccess">100%</div>
                <div class="text-sm text-gray-400">Success Rate</div>
              </div>
            </div>
          </div>
        </main>

        <!-- Analyze Workspace (hidden by default) -->
        <main id="analyzeWorkspace" class="hidden acrylic--editor rounded-3xl flex-1 flex flex-col min-h-0">
          <div class="flex-1 p-6 md:p-8 overflow-y-auto" id="analyzeScrollContainer">
            <div class="w-full max-w-3xl mx-auto space-y-6">

              <!-- Title -->
              <h1
                class="text-center text-3xl md:text-4xl font-black text-transparent bg-clip-text bg-gradient-to-r from-primary via-cyan-400 to-primary animate-gradient-x tracking-wider"
                style="font-family: 'Orbitron', sans-serif; letter-spacing: 0.1em;">
                PROMPT PLAYGROUND
              </h1>

              <!-- Input Editor with Line Numbers -->
              <div class="editor-container" style="height: 400px;">
                <div class="line-numbers" id="analyzeLineNumbers">
                  1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10
                </div>
                <div class="editor-wrapper">
                  <textarea id="analyzeTextarea"
                    class="editor-area w-full h-full bg-transparent border-none focus:border-none focus:ring-0 p-3 md:p-4 font-mono text-[14px] md:text-[15px] text-gray-100 placeholder-gray-500 resize-none"
                    placeholder="Enter text to analyze..."></textarea>
                </div>
              </div>

              <!-- Analyze Button -->
              <div class="flex justify-end">
                <button id="analyzeButton"
                  class="px-6 py-3 bg-primary hover:bg-primaryDarker rounded-xl text-black font-semibold transition-all duration-200 shadow-lg shadow-primary/30 flex items-center gap-2">
                  <span class="material-icons text-[20px]">analytics</span>
                  <span>Analyze</span>
                </button>
              </div>

              <!-- Output Panel (hidden by default, revealed after clicking Analyze) -->
              <div id="analyzeOutput" class="hidden space-y-4 animate-fade-in">
                <div class="h-px bg-gradient-to-r from-transparent via-white/10 to-transparent"></div>

                <!-- Output Editor with Line Numbers (read-only, slightly smaller) -->
                <div class="editor-container" style="height: 300px;">
                  <div class="line-numbers" id="outputLineNumbers">
                    1<br>2<br>3<br>4<br>5
                  </div>
                  <div class="editor-wrapper">
                    <textarea id="outputTextarea"
                      class="editor-area w-full h-full bg-transparent border-none focus:border-none focus:ring-0 p-3 md:p-4 font-mono text-[14px] md:text-[15px] text-gray-300 placeholder-gray-500 resize-none"
                      placeholder="Analysis results will appear here..." readonly></textarea>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </main>

        <!-- AI Assistant -->
        <aside id="assistant-panel"
          class="acrylic--assistant w-72 md:w-80 flex-shrink-0 rounded-3xl overflow-hidden relative transition-all duration-300 ease-in-out">
          <!-- Collapsed State Rail (hidden by default) -->
          <div id="collapsed-rail"
            class="hidden absolute top-0 left-0 w-full h-full flex items-start justify-center pt-4 bg-white/5 backdrop-blur-sm border border-white/10 rounded-3xl z-10">
            <button id="expand-toggle"
              class="w-8 h-8 rounded-full text-gray-300 hover:text-primary hover:bg-white/10 transition-colors duration-200 flex items-center justify-center"
              aria-controls="assistant-panel" aria-expanded="false" title="Expand assistant">
              <i class="fa-solid fa-chevron-left text-sm"></i>
            </button>
          </div>

          <!-- Main Assistant Content -->
          <div id="assistant-content" class="transition-opacity duration-300 ease-in-out">
            <div class="p-3 md:p-4 border-b border-white/10">
              <h2 class="text-xl md:text-2xl font-semibold text-white flex items-center gap-2">
                <button id="assistant-toggle"
                  class="mr-2 w-8 h-8 rounded-full text-gray-300 hover:text-primary hover:bg-white/10 transition-colors duration-200 flex items-center justify-center"
                  aria-controls="assistant-panel" aria-expanded="true" title="Collapse assistant">
                  <i class="fa-solid fa-chevron-right text-sm"></i>
                </button>
                <span class="material-icons text-primary text-[22px]">auto_awesome</span>
                <span class="assistant-title">AI Assistant</span>
              </h2>

              <!-- Mode Selector Pills -->
              <div class="flex items-center mt-3 p-1 bg-white/5 rounded-full border border-white/10 relative">
                <!-- Sliding background indicator -->
                <div id="pillSlider"
                  class="absolute top-1 left-1 w-[calc(50%-2px)] h-[calc(100%-8px)] bg-primary rounded-full transition-all duration-300 ease-out shadow-sm">
                </div>
                <button id="askMode"
                  class="mode-pill flex-1 px-3 py-1.5 text-sm font-medium rounded-full transition-all duration-200 relative z-10 text-black"
                  data-mode="ask">
                  Ask
                </button>
                <button id="agentMode"
                  class="mode-pill flex-1 px-3 py-1.5 text-sm font-medium rounded-full transition-all duration-200 relative z-10 text-gray-300 hover:text-white"
                  data-mode="agent">
                  Agent
                </button>
              </div>
            </div>

            <!-- Chat Transcript Container -->
            <div class="flex-1 relative overflow-hidden">
              <!-- Chat Transcript -->
              <div id="chat-transcript" class="h-full p-3 md:p-4 overflow-y-auto space-y-3 scroll-smooth"
                style="padding-bottom: 120px; max-height: calc(100vh - 280px);" role="log"
                aria-label="Chat conversation" tabindex="0">
                <!-- Dynamic messages will be inserted here -->
              </div>

              <!-- Jump to Latest Button (hidden by default) -->
              <div id="jump-to-latest" class="hidden absolute bottom-24 right-4 z-10">
                <button
                  class="flex items-center gap-2 px-3 py-2 bg-primary text-black rounded-full shadow-lg hover:bg-primary/90 transition-all duration-200 text-sm font-medium"
                  aria-label="Scroll to latest message" title="Jump to latest message">
                  <span class="material-icons text-[16px]">keyboard_arrow_down</span>
                  <span>Latest</span>
                </button>
              </div>
            </div>

            <!-- Typing Indicator (hidden by default) -->
            <div id="typing-indicator" class="hidden px-3 md:px-4 pb-2" aria-live="polite">
              <div class="flex items-start gap-3">
                <div
                  class="w-7 h-7 rounded-full bg-primary flex-shrink-0 grid place-items-center shadow-md shadow-primary/30">
                  <span class="material-icons text-black text-[18px]">auto_awesome</span>
                </div>
                <div class="bg-white/5 border border-white/10 rounded-2xl p-3 max-w-[85%]">
                  <div class="flex items-center gap-2">
                    <div class="flex gap-1">
                      <div class="w-2 h-2 bg-gray-400 rounded-full animate-pulse"></div>
                      <div class="w-2 h-2 bg-gray-400 rounded-full animate-pulse" style="animation-delay: 0.2s;"></div>
                      <div class="w-2 h-2 bg-gray-400 rounded-full animate-pulse" style="animation-delay: 0.4s;"></div>
                    </div>
                    <span class="text-sm text-gray-300">AI is typing...</span>
                  </div>
                </div>
              </div>
            </div>

            <!-- Chat Input Area -->
            <div
              class="absolute bottom-0 left-0 right-0 p-3 md:p-4 border-top border-white/10 bg-black/20 backdrop-blur-sm">
              <!-- Error Toast (hidden by default) -->
              <div id="error-toast"
                class="hidden mb-2 p-2 bg-red-500/20 border border-red-500/30 rounded-xl text-red-300 text-sm"
                role="alert" aria-live="assertive">
                Failed to send message. Please try again.
              </div>

              <!-- New Messages Notification (hidden by default) -->
              <div id="new-messages-notification"
                class="hidden mb-2 p-2 bg-primary/20 border border-primary/30 rounded-xl text-primary text-sm cursor-pointer hover:bg-primary/30 transition-colors"
                role="button" tabindex="0" aria-label="Scroll to new messages">
                 New messages
              </div>

              <div class="flex items-end gap-2">
                <button id="attach-button"
                  class="p-2 rounded-full text-gray-300 hover:bg-white/10 hover:text-primary transition flex-shrink-0"
                  aria-label="Attach file (coming soon)" disabled>
                  <span class="material-icons">add</span>
                </button>
                <div class="relative flex-1">
                  <textarea id="message-input"
                    class="w-full pl-3 pr-10 py-2 bg-white/5 border border-white/10 rounded-xl focus:ring-2 focus:ring-primary/50 focus:border-transparent placeholder-gray-500 text-base resize-none overflow-y-auto min-h-[40px] max-h-[144px]"
                    placeholder="Say hello..." rows="1" aria-label="Type your message"
                    aria-describedby="input-hint"></textarea>
                  <button id="send-button"
                    class="absolute right-1.5 bottom-1.5 w-8 h-8 rounded-full text-gray-400 hover:bg-primary/20 hover:text-primary transition grid place-items-center disabled:opacity-50 disabled:cursor-not-allowed disabled:hover:bg-transparent disabled:hover:text-gray-400"
                    disabled aria-label="Send message">
                    <span class="material-icons text-[18px]">send</span>
                  </button>
                </div>
              </div>

              <!-- Input Hint -->
              <div id="input-hint" class="mt-1 text-xs text-gray-500">
                Press Enter to send, Shift+Enter for new line
              </div>
            </div>
          </div> <!-- End assistant-content -->
        </aside>



      </div>
    </div>

    <script>
      // -------- Cursor glow follower (smooth + efficient) --------
      (function () {
        const glow = document.getElementById('cursor-glow');
        if (!glow) return;

        const reduceMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
        let targetX = window.innerWidth / 2, targetY = window.innerHeight / 2;
        let currentX = targetX, currentY = targetY;
        const lerp = (a, b, n) => (1 - n) * a + n * b;
        const ease = 0.14; // follow speed

        function onLeave() { glow.style.opacity = '0.0'; }
        function onEnter() { glow.style.opacity = '0.8'; }
        window.addEventListener('mouseleave', onLeave);
        window.addEventListener('mouseenter', onEnter);

        window.addEventListener('mousemove', (e) => {
          targetX = e.clientX;
          targetY = e.clientY;
          if (!reduceMotion) glow.style.opacity = '0.85';
          clearTimeout(window.__glowIdleTimer);
          window.__glowIdleTimer = setTimeout(() => {
            glow.style.opacity = '0.65';
          }, 900);
        }, { passive: true });

        function animate() {
          if (reduceMotion) {
            glow.style.transform = `translate(${targetX - 150}px, ${targetY - 150}px)`;
          } else {
            currentX = lerp(currentX, targetX, ease);
            currentY = lerp(currentY, targetY, ease);
            glow.style.transform = `translate(${currentX - 150}px, ${currentY - 150}px)`;
          }
          requestAnimationFrame(animate);
        }
        animate();

        window.addEventListener('resize', () => {
          targetX = Math.min(targetX, window.innerWidth);
          targetY = Math.min(targetY, window.innerHeight);
        });
      })();

      // -------- Line numbers synchronization (drift-free) --------
      (function () {
        const textEditor = document.getElementById('textEditor');
        const lineNumbers = document.getElementById('lineNumbers');
        if (!textEditor || !lineNumbers) return;

        let lockedMetrics = null;

        // Lock font metrics to ensure perfect alignment
        function lockMetrics() {
          const editorStyle = window.getComputedStyle(textEditor);
          const fontFamily = editorStyle.fontFamily;
          const fontSize = editorStyle.fontSize;
          const lineHeight = editorStyle.lineHeight;
          const paddingTop = editorStyle.paddingTop;
          const paddingBottom = editorStyle.paddingBottom;

          // Convert line-height to exact px value
          const lineHeightPx = lineHeight === 'normal'
            ? Math.floor(parseFloat(fontSize) * 1.6)
            : parseFloat(lineHeight);

          // Apply identical metrics to both elements
          const metrics = {
            fontFamily,
            fontSize,
            lineHeight: `${lineHeightPx}px`,
            paddingTop,
            paddingBottom
          };

          Object.assign(lineNumbers.style, metrics);
          Object.assign(textEditor.style, metrics);

          lockedMetrics = { ...metrics, lineHeightPx };
          return lockedMetrics;
        }

        // Clean line number rendering
        function renderLineNumbers() {
          if (!lockedMetrics) lockMetrics();
          const content = textEditor.value;
          const lineCount = content.split('\n').length;
          const numbers = Array.from({ length: lineCount }, (_, i) => i + 1);
          lineNumbers.innerHTML = numbers.join('<br>');
        }

        // Sync scroll positions
        function syncScroll() {
          lineNumbers.scrollTop = textEditor.scrollTop;
        }

        // Event handlers
        function handleInput() {
          renderLineNumbers();
          // Track user editing to prevent AI overwrites
          window.lastUserEdit = Date.now();
        }
        function handleScroll() { syncScroll(); }
        function handleResize() { lockMetrics(); renderLineNumbers(); }

        // Only attach event listeners if using traditional text editor mode
        // (Currently disabled for formatted view)
        const useFormattedEditor = true; // Set to false to use traditional textarea mode

        if (!useFormattedEditor) {
          // Attach all event listeners
          textEditor.addEventListener('input', handleInput);
          textEditor.addEventListener('paste', handleInput);
          textEditor.addEventListener('scroll', handleScroll);
          window.addEventListener('resize', handleResize);

          // Handle undo/redo via mutation observer
          const observer = new MutationObserver(handleInput);
          observer.observe(textEditor, { attributes: true, attributeFilter: ['value'] });

          // Initialize
          lockMetrics();
          renderLineNumbers();
          syncScroll();
        } else {
          // Hide line numbers and textarea for formatted view
          lineNumbers.classList.add('hidden');
          textEditor.classList.add('hidden');
        }
      })();
    </script>

    <!-- Settings Panel Navigation Script -->
    <script>
      (function () {
        // Get UI elements
        const settingsBtn = document.getElementById('settingsBtn');
        const editorBtn = document.getElementById('editorBtn');
        const analyzeBtn = document.getElementById('analyzeBtn');
        const backToEditor = document.getElementById('backToEditor');
        const editorPanel = document.getElementById('editor-pane');
        const promptInjectionsPanel = document.getElementById('promptInjectionsPanel');
        const analyzeWorkspace = document.getElementById('analyzeWorkspace');

        // History panels
        const historyPanel = document.getElementById('history-panel');
        const promptInjectionsHistory = document.getElementById('promptInjectionsHistory');

        // AI Assistant panels
        const assistantPanel = document.getElementById('assistant-panel');

        // Global mode tracking
        window.promptInjectionMode = false;

        // Update UI states
        function showEditor() {
          window.promptInjectionMode = false;

          // Show editor panels
          editorPanel.classList.remove('hidden');
          historyPanel.classList.remove('hidden');
          assistantPanel.classList.remove('hidden');

          // Hide prompt injection panels and analyze workspace
          promptInjectionsPanel.classList.add('hidden');
          promptInjectionsHistory.classList.add('hidden');
          analyzeWorkspace.classList.add('hidden');

          // Update button states
          editorBtn.classList.add('text-black', 'bg-primary', 'shadow-lg', 'shadow-primary/30');
          editorBtn.classList.remove('text-gray-300');
          settingsBtn.classList.remove('text-black', 'bg-primary', 'shadow-lg', 'shadow-primary/30');
          settingsBtn.classList.add('text-gray-300');
          analyzeBtn.classList.remove('text-black', 'bg-primary', 'shadow-lg', 'shadow-primary/30');
          analyzeBtn.classList.add('text-gray-300');

          // Sync text editor with the most recent AI response when returning to editor mode
          setTimeout(() => {
            if (window.chatManager && window.chatManager.messages) {
              const lastAiMessage = window.chatManager.messages
                .slice()
                .reverse()
                .find(msg => msg.role === 'ai');

              if (lastAiMessage) {
                window.chatManager.updateTextEditor(lastAiMessage.content);
                console.log('Mode Switch: Formatted editor synced with latest AI response');
              }
            }
          }, 100);
        }

        function showSettings() {
          window.promptInjectionMode = true;

          // Hide editor panels and analyze workspace
          editorPanel.classList.add('hidden');
          historyPanel.classList.add('hidden');
          assistantPanel.classList.add('hidden');
          analyzeWorkspace.classList.add('hidden');

          // Show prompt injection panels
          promptInjectionsPanel.classList.remove('hidden');
          promptInjectionsHistory.classList.remove('hidden');

          // Update button states
          settingsBtn.classList.add('text-black', 'bg-primary', 'shadow-lg', 'shadow-primary/30');
          settingsBtn.classList.remove('text-gray-300');
          editorBtn.classList.remove('text-black', 'bg-primary', 'shadow-lg', 'shadow-primary/30');
          editorBtn.classList.add('text-gray-300');
          analyzeBtn.classList.remove('text-black', 'bg-primary', 'shadow-lg', 'shadow-primary/30');
          analyzeBtn.classList.add('text-gray-300');

          // Sync with Supabase when entering prompt injection mode
          if (window.promptInjectionSupabase) {
            window.promptInjectionSupabase.sync().then(() => {
              // Update security history display after sync
              if (typeof window.updateSecurityHistoryDisplay === 'function') {
                window.updateSecurityHistoryDisplay();
              }
            });
          } else {
            // Update security history display when switching to security mode
            if (typeof window.updateSecurityHistoryDisplay === 'function') {
              window.updateSecurityHistoryDisplay();
            }
          }
        }

        function showAnalyze() {
          window.promptInjectionMode = false;

          // Hide all other panels
          editorPanel.classList.add('hidden');
          historyPanel.classList.add('hidden');
          assistantPanel.classList.add('hidden');
          promptInjectionsPanel.classList.add('hidden');
          promptInjectionsHistory.classList.add('hidden');

          // Show analyze workspace
          analyzeWorkspace.classList.remove('hidden');

          // Reset scroll position to top
          const analyzeScrollContainer = document.getElementById('analyzeScrollContainer');
          if (analyzeScrollContainer) {
            analyzeScrollContainer.scrollTop = 0;
          }

          // Update button states
          analyzeBtn.classList.add('text-black', 'bg-primary', 'shadow-lg', 'shadow-primary/30');
          analyzeBtn.classList.remove('text-gray-300');
          editorBtn.classList.remove('text-black', 'bg-primary', 'shadow-lg', 'shadow-primary/30');
          editorBtn.classList.add('text-gray-300');
          settingsBtn.classList.remove('text-black', 'bg-primary', 'shadow-lg', 'shadow-primary/30');
          settingsBtn.classList.add('text-gray-300');
        }

        // Event listeners
        settingsBtn.addEventListener('click', showSettings);
        editorBtn.addEventListener('click', showEditor);
        backToEditor.addEventListener('click', showEditor);
        analyzeBtn.addEventListener('click', showAnalyze);

        // Initialize - ensure editor mode is active by default
        showEditor(); // Ensure proper initial state
      })();

      // ========== ANALYZE WORKSPACE FUNCTIONALITY ==========
      (function () {
        'use strict';

        const analyzeTextarea = document.getElementById('analyzeTextarea');
        const analyzeLineNumbers = document.getElementById('analyzeLineNumbers');
        const analyzeButton = document.getElementById('analyzeButton');
        const analyzeOutput = document.getElementById('analyzeOutput');
        const outputTextarea = document.getElementById('outputTextarea');
        const outputLineNumbers = document.getElementById('outputLineNumbers');

        if (!analyzeTextarea || !analyzeLineNumbers || !analyzeButton || !analyzeOutput || !outputTextarea || !outputLineNumbers) {
          return;
        }

        // Lorem ipsum placeholder text
        const loremIpsum = `Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.

Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo.

Nemo enim ipsam voluptatem quia voluptas sit aspernatur aut odit aut fugit, sed quia consequuntur magni dolores eos qui ratione voluptatem sequi nesciunt.`;

        let inputLockedMetrics = null;
        let outputLockedMetrics = null;

        // -------- Input Editor Line Numbers --------
        function lockInputMetrics() {
          const editorStyle = window.getComputedStyle(analyzeTextarea);
          const fontFamily = editorStyle.fontFamily;
          const fontSize = editorStyle.fontSize;
          const lineHeight = editorStyle.lineHeight;
          const paddingTop = editorStyle.paddingTop;
          const paddingBottom = editorStyle.paddingBottom;

          const lineHeightPx = lineHeight === 'normal'
            ? Math.floor(parseFloat(fontSize) * 1.6)
            : parseFloat(lineHeight);

          const metrics = {
            fontFamily,
            fontSize,
            lineHeight: `${lineHeightPx}px`,
            paddingTop,
            paddingBottom
          };

          Object.assign(analyzeLineNumbers.style, metrics);
          Object.assign(analyzeTextarea.style, metrics);

          inputLockedMetrics = { ...metrics, lineHeightPx };
          return inputLockedMetrics;
        }

        function renderInputLineNumbers() {
          if (!inputLockedMetrics) lockInputMetrics();
          const content = analyzeTextarea.value;
          const lineCount = content.split('\n').length;
          const numbers = Array.from({ length: lineCount }, (_, i) => i + 1);
          analyzeLineNumbers.innerHTML = numbers.join('<br>');
        }

        function syncInputScroll() {
          analyzeLineNumbers.scrollTop = analyzeTextarea.scrollTop;
        }

        // -------- Output Editor Line Numbers --------
        function lockOutputMetrics() {
          const editorStyle = window.getComputedStyle(outputTextarea);
          const fontFamily = editorStyle.fontFamily;
          const fontSize = editorStyle.fontSize;
          const lineHeight = editorStyle.lineHeight;
          const paddingTop = editorStyle.paddingTop;
          const paddingBottom = editorStyle.paddingBottom;

          const lineHeightPx = lineHeight === 'normal'
            ? Math.floor(parseFloat(fontSize) * 1.6)
            : parseFloat(lineHeight);

          const metrics = {
            fontFamily,
            fontSize,
            lineHeight: `${lineHeightPx}px`,
            paddingTop,
            paddingBottom
          };

          Object.assign(outputLineNumbers.style, metrics);
          Object.assign(outputTextarea.style, metrics);

          outputLockedMetrics = { ...metrics, lineHeightPx };
          return outputLockedMetrics;
        }

        function renderOutputLineNumbers() {
          if (!outputLockedMetrics) lockOutputMetrics();
          const content = outputTextarea.value;
          const lineCount = content.split('\n').length;
          const numbers = Array.from({ length: lineCount }, (_, i) => i + 1);
          outputLineNumbers.innerHTML = numbers.join('<br>');
        }

        function syncOutputScroll() {
          outputLineNumbers.scrollTop = outputTextarea.scrollTop;
        }

        // -------- Event Handlers --------
        function handleInputChange() { renderInputLineNumbers(); }
        function handleInputScroll() { syncInputScroll(); }
        function handleOutputScroll() { syncOutputScroll(); }
        function handleResize() {
          lockInputMetrics();
          renderInputLineNumbers();
          if (!analyzeOutput.classList.contains('hidden')) {
            lockOutputMetrics();
            renderOutputLineNumbers();
          }
        }

        // Analyze button click handler
        function handleAnalyze() {
          // Show output panel with animation
          analyzeOutput.classList.remove('hidden');

          // Update output textarea with lorem ipsum
          outputTextarea.value = loremIpsum;

          // Update output line numbers
          lockOutputMetrics();
          renderOutputLineNumbers();
          syncOutputScroll();

          // Smooth scroll to output without jumping
          setTimeout(() => {
            const analyzeScrollContainer = document.getElementById('analyzeScrollContainer');
            if (analyzeScrollContainer && analyzeOutput) {
              const outputRect = analyzeOutput.getBoundingClientRect();
              const containerRect = analyzeScrollContainer.getBoundingClientRect();

              // Only scroll if output is not fully visible
              if (outputRect.bottom > containerRect.bottom) {
                analyzeOutput.scrollIntoView({ behavior: 'smooth', block: 'end' });
              }
            }
          }, 150);
        }

        // Attach event listeners
        analyzeTextarea.addEventListener('input', handleInputChange);
        analyzeTextarea.addEventListener('paste', handleInputChange);
        analyzeTextarea.addEventListener('scroll', handleInputScroll);
        outputTextarea.addEventListener('scroll', handleOutputScroll);
        window.addEventListener('resize', handleResize);
        analyzeButton.addEventListener('click', handleAnalyze);

        // Handle undo/redo via mutation observer for input
        const inputObserver = new MutationObserver(handleInputChange);
        inputObserver.observe(analyzeTextarea, { attributes: true, attributeFilter: ['value'] });

        // Handle font load events
        if (document.fonts) {
          document.fonts.addEventListener('loadingdone', () => {
            setTimeout(() => {
              lockInputMetrics();
              renderInputLineNumbers();
              if (!analyzeOutput.classList.contains('hidden')) {
                lockOutputMetrics();
                renderOutputLineNumbers();
              }
            }, 50);
          });
        }

        // Initialize
        lockInputMetrics();
        renderInputLineNumbers();
        syncInputScroll();

        console.log('Analyze workspace initialized');
      })();

      // ========== PROMPT INJECTION FUNCTIONALITY ==========

      // Global state for prompt injection
      window.promptInjectionState = {
        history: JSON.parse(localStorage.getItem('securityHistory') || '[]'),
        stats: JSON.parse(localStorage.getItem('securityStats') || '{"processed": 0, "blocked": 0, "successRate": 100}')
      };

      // ========== SUPABASE INTEGRATION FOR PROMPT INJECTIONS ==========
      (function () {
        'use strict';

        const SUPABASE_URL = 'https://qnbvnczctgbclolvkjcb.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InFuYnZuY3pjdGdiY2xvbHZramNiIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjI1NTg3NDIsImV4cCI6MjA3ODEzNDc0Mn0.v5t8eMJjpPtdIn6oKXshjuIH0shlztIp9fWBrRjnrGg';

        let supabaseClient = null;
        let currentUserId = null;

        // Initialize Supabase client for prompt injection
        function getSupabaseClient() {
          if (!supabaseClient && window.supabase) {
            const { createClient } = window.supabase;
            supabaseClient = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
          }
          return supabaseClient;
        }

        // Get current user ID
        async function getCurrentUserId() {
          if (currentUserId) return currentUserId;

          const client = getSupabaseClient();
          if (!client) return null;

          try {
            const { data: { user }, error } = await client.auth.getUser();
            if (error) {
              console.warn('Failed to get user:', error);
              return null;
            }
            currentUserId = user?.id || null;
            return currentUserId;
          } catch (error) {
            console.error('Error getting current user:', error);
            return null;
          }
        }

        // Save injection to Supabase
        async function saveInjectionToSupabase(prompt, score) {
          const userId = await getCurrentUserId();
          if (!userId) {
            console.warn('No user logged in, skipping Supabase save');
            return null;
          }

          const client = getSupabaseClient();
          if (!client) return null;

          try {

            const { data, error } = await client
              .from('Injections')
              .insert([{
                user_id: userId,
                prompt: prompt,
                risk: score
              }])

              .select();


            if (error) {
              console.error('Failed to save injection to Supabase:', error);
              return null;
            }

            console.log(' Injection saved to Supabase:', data);
            return data?.[0] || null;
          } catch (error) {
            console.error('Error saving injection:', error);
            return null;
          }
        }

        // Update user stats in Supabase
        async function updateUserStatsInSupabase(stats) {
          const userId = await getCurrentUserId();
          if (!userId) {
            console.warn('No user logged in, skipping stats update');
            return false;
          }

          const client = getSupabaseClient();
          if (!client) return false;

          try {
            const { error } = await client
              .from('Users')
              .update({
                promptsanalyzed: stats.processed,
                threatsblocked: stats.blocked,
                successrate: stats.successRate
              })
              .eq('id', userId);

            if (error) {
              console.error('Failed to update user stats in Supabase:', error);
              return false;
            }

            console.log(' User stats updated in Supabase');
            return true;
          } catch (error) {
            console.error('Error updating user stats:', error);
            return false;
          }
        }

        // Load injection history from Supabase
        async function loadInjectionsFromSupabase() {
          const userId = await getCurrentUserId();
          if (!userId) {
            console.warn('No user logged in, skipping injection load');
            return [];
          }

          const client = getSupabaseClient();
          if (!client) return [];

          try {
            const { data, error } = await client
              .from('Injections')
              .select('*')
              .eq('user_id', userId)
              .order('created_at', { ascending: false })
              .limit(50);

            if (error) {
              console.error('Failed to load injections from Supabase:', error);
              return [];
            }

            console.log(' Loaded injections from Supabase:', data?.length || 0);
            return data || [];
          } catch (error) {
            console.error('Error loading injections:', error);
            return [];
          }
        }

        // Load user stats from Supabase
        async function loadUserStatsFromSupabase() {
          const userId = await getCurrentUserId();
          if (!userId) {
            console.warn('No user logged in, skipping stats load');
            return null;
          }

          const client = getSupabaseClient();
          if (!client) return null;

          try {
            const { data, error } = await client
              .from('Users')
              .select('promptsanalyzed, threatsblocked, successrate')
              .eq('id', userId)
              .single();

            if (error) {
              console.error('Failed to load user stats from Supabase:', error);
              return null;
            }

            console.log(' Loaded user stats from Supabase:', data);
            return {
              processed: data?.promptsanalyzed || 0,
              blocked: data?.threatsblocked || 0,
              successRate: data?.successrate || 100
            };
          } catch (error) {
            console.error('Error loading user stats:', error);
            return null;
          }
        }

        // Sync local state with Supabase on page load
        async function syncWithSupabase() {
          console.log(' Syncing prompt injection data with Supabase...');

          // Load stats from Supabase
          const supabaseStats = await loadUserStatsFromSupabase();
          if (supabaseStats) {
            window.promptInjectionState.stats = supabaseStats;
            localStorage.setItem('securityStats', JSON.stringify(supabaseStats));

            // Update UI
            if (typeof window.updatePromptInjectionStatsDisplay === 'function') {
              window.updatePromptInjectionStatsDisplay();
            }
          }

          // Load injection history from Supabase
          const supabaseInjections = await loadInjectionsFromSupabase();
          if (supabaseInjections.length > 0) {
            // Convert Supabase format to local format
            const history = supabaseInjections.map(inj => ({
              id: inj.id,
              prompt: inj.prompt.substring(0, 200) + (inj.prompt.length > 200 ? '...' : ''),
              fullPrompt: inj.prompt,
              score: inj.risk,
              heuristics: [],
              timestamp: inj.created_at,
              timeAgo: getTimeAgo(new Date(inj.created_at))
            }));

            window.promptInjectionState.history = history;
            localStorage.setItem('securityHistory', JSON.stringify(history));

            // Update history display
            if (window.promptInjectionMode && typeof window.updateSecurityHistoryDisplay === 'function') {
              window.updateSecurityHistoryDisplay();
            }
          }

          console.log(' Supabase sync completed');
        }

        // Helper function to get time ago string
        function getTimeAgo(date) {
          const now = new Date();
          const diffInSeconds = Math.floor((now - date) / 1000);

          if (diffInSeconds < 60) return 'Just now';
          if (diffInSeconds < 3600) return `${Math.floor(diffInSeconds / 60)} min ago`;
          if (diffInSeconds < 86400) return `${Math.floor(diffInSeconds / 3600)} hours ago`;
          return `${Math.floor(diffInSeconds / 86400)} days ago`;
        }

        // Expose functions to global scope
        window.promptInjectionSupabase = {
          saveInjection: saveInjectionToSupabase,
          updateStats: updateUserStatsInSupabase,
          loadInjections: loadInjectionsFromSupabase,
          loadStats: loadUserStatsFromSupabase,
          sync: syncWithSupabase,
          getClient: getSupabaseClient,
          getCurrentUserId: getCurrentUserId
        };

        // Auto-sync on page load after a short delay
        setTimeout(() => {
          syncWithSupabase();
        }, 1000);

      })();

      // Prompt Injection Main Functionality
      (function () {
        'use strict';

        // DOM Elements
        const analyzeBtn = document.getElementById('analyzePromptBtn');
        const clearBtn = document.getElementById('clearPromptBtn');
        const promptInput = document.getElementById('mainPromptInput');
        const resultsSection = document.getElementById('resultsSection');
        const scoreValue = document.getElementById('scoreValue');
        const scoreBar = document.getElementById('scoreBar');
        const scoreDescription = document.getElementById('scoreDescription');
        const explanationContent = document.getElementById('explanationContent');
        const explanationLoading = document.getElementById('explanationLoading');
        const explanationText = document.getElementById('explanationText');
        const patternsList = document.getElementById('patternsList');

        // Stats elements
        const statsProcessed = document.getElementById('statsProcessed');
        const statsBlocked = document.getElementById('statsBlocked');
        const statsSuccess = document.getElementById('statsSuccess');

        let isAnalyzing = false;

        // Update stats display
        function updateStatsDisplay() {
          const stats = window.promptInjectionState.stats;
          statsProcessed.textContent = stats.processed;
          statsBlocked.textContent = stats.blocked;
          statsSuccess.textContent = stats.successRate + '%';
        }

        // Get risk color and description
        function getRiskInfo(score) {
          if (score >= 80) return { color: '#ef4444', description: 'Very High Risk', class: 'text-red-400' };
          if (score >= 60) return { color: '#f97316', description: 'High Risk', class: 'text-orange-400' };
          if (score >= 40) return { color: '#eab308', description: 'Medium Risk', class: 'text-yellow-400' };
          if (score >= 20) return { color: '#06b6d4', description: 'Low Risk', class: 'text-cyan-400' };
          return { color: '#22c55e', description: 'Very Low Risk', class: 'text-green-400' };
        }

        // Display analysis results
        function displayResults(data) {
          const score = parseFloat(data.score) || 0;
          const riskInfo = getRiskInfo(score);

          // Update score display
          scoreValue.textContent = score + '%';
          scoreValue.className = `text-2xl font-bold ${riskInfo.class}`;
          scoreBar.style.width = score + '%';
          scoreBar.style.backgroundColor = riskInfo.color;
          scoreDescription.textContent = riskInfo.description;
          scoreDescription.className = `text-sm ${riskInfo.class}`;

          // Display detected patterns
          if (data.heuristics && data.heuristics.length > 0) {
            patternsList.innerHTML = data.heuristics.map(pattern => `
            <div class="p-3 rounded-lg bg-red-500/10 border border-red-500/20 flex items-start gap-3">
              <span class="material-icons text-red-400 text-[18px] flex-shrink-0 mt-0.5">warning</span>
              <div class="flex-1">
                <div class="text-red-400 font-medium text-sm">Security Pattern Detected</div>
                <div class="text-gray-300 text-sm mt-1">${pattern}</div>
              </div>
            </div>
          `).join('');
          } else {
            patternsList.innerHTML = `
            <div class="p-3 rounded-lg bg-green-500/10 border border-green-500/20 flex items-start gap-3">
              <span class="material-icons text-green-400 text-[18px] flex-shrink-0 mt-0.5">check_circle</span>
              <div class="flex-1">
                <div class="text-green-400 font-medium text-sm">No Suspicious Patterns</div>
                <div class="text-gray-300 text-sm mt-1">No known injection patterns detected in this prompt</div>
              </div>
            </div>
          `;
          }

          resultsSection.classList.remove('hidden');
        }

        // Get AI explanation from Gemini
        async function getAIExplanation(prompt, score) {
          try {
            explanationLoading.classList.remove('hidden');
            explanationText.classList.add('hidden');

            const response = await fetch('/api/prompt_injection_detector/explain', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ prompt, score, model: 'prompt_injection_detector' })
            });

            if (!response.ok) throw new Error(`HTTP ${response.status}`);

            const data = await response.json();

            explanationLoading.classList.add('hidden');
            explanationText.classList.remove('hidden');
            explanationText.innerHTML = data.explanation || 'No explanation available.';

          } catch (error) {
            console.error('Failed to get AI explanation:', error);
            explanationLoading.classList.add('hidden');
            explanationText.classList.remove('hidden');
            explanationText.innerHTML = `
            <div class="text-red-400 text-sm">
              Failed to get AI explanation: ${error.message}
            </div>
          `;
          }
        }

        // Add to history
        function addToHistory(prompt, score, heuristics, timestamp = new Date()) {
          const historyItem = {
            id: Date.now(),
            prompt: prompt.substring(0, 200) + (prompt.length > 200 ? '...' : ''),
            fullPrompt: prompt,
            score,
            heuristics: heuristics || [],
            timestamp: timestamp.toISOString(),
            timeAgo: getTimeAgo(timestamp)
          };

          window.promptInjectionState.history.unshift(historyItem);

          // Keep only last 50 items
          if (window.promptInjectionState.history.length > 50) {
            window.promptInjectionState.history = window.promptInjectionState.history.slice(0, 50);
          }

          localStorage.setItem('securityHistory', JSON.stringify(window.promptInjectionState.history));

          // Update history display if we're in security mode
          if (window.promptInjectionMode) {
            window.updateSecurityHistoryDisplay();
          }

          // Save to Supabase
          if (window.promptInjectionSupabase) {
            window.promptInjectionSupabase.saveInjection(prompt, score)
              .then(result => {
                if (result) {
                  console.log(' Injection saved to Supabase');
                }
              })
              .catch(err => {
                console.warn('Failed to save injection to Supabase:', err);
              });
          }
        }

        // Update stats
        function updateStats(score) {
          const stats = window.promptInjectionState.stats;
          stats.processed++;

          if (score >= 60) { // Consider high scores as blocked
            stats.blocked++;
          }

          stats.successRate = Math.round(((stats.processed - stats.blocked) / stats.processed) * 100);

          localStorage.setItem('securityStats', JSON.stringify(stats));
          updateStatsDisplay();

          // Update stats in Supabase
          if (window.promptInjectionSupabase) {
            window.promptInjectionSupabase.updateStats(stats)
              .then(result => {
                if (result) {
                  console.log(' User stats updated in Supabase');
                }
              })
              .catch(err => {
                console.warn('Failed to update stats in Supabase:', err);
              });
          }
        }

        // Make updateStatsDisplay globally accessible for Supabase sync
        window.updatePromptInjectionStatsDisplay = updateStatsDisplay;

        // Helper function to get time ago string
        function getTimeAgo(date) {
          const now = new Date();
          const diffInSeconds = Math.floor((now - new Date(date)) / 1000);

          if (diffInSeconds < 60) return 'Just now';
          if (diffInSeconds < 3600) return `${Math.floor(diffInSeconds / 60)} min ago`;
          if (diffInSeconds < 86400) return `${Math.floor(diffInSeconds / 3600)} hours ago`;
          return `${Math.floor(diffInSeconds / 86400)} days ago`;
        }

        // Main analysis function
        async function analyzePrompt() {
          if (isAnalyzing) return;

          const prompt = promptInput.value.trim();
          if (!prompt) {
            alert('Please enter a prompt to analyze');
            return;
          }

          const protectionLevel = document.querySelector('input[name="mainProtectionLevel"]:checked')?.value || 'basic';

          isAnalyzing = true;
          analyzeBtn.disabled = true;
          analyzeBtn.innerHTML = `
          <div class="animate-spin rounded-full h-4 w-4 border-b-2 border-black"></div>
          Analyzing...
        `;

          try {
            // Request scoring using the local `prompt_injection_detector` model via backend
            const response = await fetch('/api/prompt_injection_detector/score', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ prompt, protectionLevel, model: 'prompt_injection_detector' })
            });

            if (!response.ok) {
              throw new Error(`Server error: ${response.status}`);
            }

            const data = await response.json();

            displayResults(data);
            addToHistory(prompt, data.score, data.heuristics);
            updateStats(data.score);

            // Show notification if there was an error or fallback
            if (data.error) {
              console.warn('Detection warning:', data.error);
            }

            // Get AI explanation
            getAIExplanation(prompt, data.score);

          } catch (error) {
            console.error('Analysis failed:', error);
            alert(`Analysis failed: ${error.message}`);
          } finally {
            isAnalyzing = false;
            analyzeBtn.disabled = false;
            analyzeBtn.innerHTML = `
            <span class="material-icons text-[18px]">security</span>
            Analyze Prompt
          `;
          }
        }

        // Clear function
        function clearPrompt() {
          promptInput.value = '';
          resultsSection.classList.add('hidden');
          promptInput.focus();
        }

        // Event listeners
        analyzeBtn.addEventListener('click', analyzePrompt);
        clearBtn.addEventListener('click', clearPrompt);

        // Enter key support
        promptInput.addEventListener('keydown', function (e) {
          if (e.key === 'Enter' && (e.ctrlKey || e.metaKey)) {
            analyzePrompt();
          }
        });

        // Initialize
        updateStatsDisplay();

      })();

      // Security History Management
      (function () {
        'use strict';

        const historyList = document.getElementById('securityHistoryList');
        const noHistoryMsg = document.getElementById('noSecurityHistory');
        const clearHistoryBtn = document.getElementById('clearHistoryBtn');
        const syncHistoryBtn = document.getElementById('syncHistoryBtn');
        const historySearch = document.getElementById('securityHistorySearch');

        // Update security history display
        window.updateSecurityHistoryDisplay = function () {
          const history = window.promptInjectionState.history;

          if (history.length === 0) {
            historyList.classList.add('hidden');
            noHistoryMsg.classList.remove('hidden');
            return;
          }

          historyList.classList.remove('hidden');
          noHistoryMsg.classList.add('hidden');

          const searchTerm = historySearch.value.toLowerCase();
          const filteredHistory = searchTerm
            ? history.filter(item => item.prompt.toLowerCase().includes(searchTerm))
            : history;

          historyList.innerHTML = filteredHistory.map(item => {
            const riskInfo = getRiskInfo(item.score);
            const riskBadge = item.score >= 60
              ? `<span class="inline-flex items-center px-2 py-1 rounded-full text-xs bg-red-500/20 border border-red-500/30 text-red-300">
                 <span class="w-2 h-2 bg-red-400 rounded-full mr-1"></span>
                 High Risk
               </span>`
              : `<span class="inline-flex items-center px-2 py-1 rounded-full text-xs bg-green-500/20 border border-green-500/30 text-green-300">
                 <span class="w-2 h-2 bg-green-400 rounded-full mr-1"></span>
                 Safe
               </span>`;

            return `
            <li>
              <a class="block p-3 rounded-2xl bg-transparent hover:bg-white/5 border border-transparent hover:border-white/10 transition cursor-pointer security-history-item"
                data-item-id="${item.id}">
                <div class="flex items-start justify-between mb-2">
                  <p class="font-medium text-white text-sm">Security Scan</p>
                  ${riskBadge}
                </div>
                <p class="text-[13px] text-gray-400 truncate mb-1">${item.prompt}</p>
                <div class="flex items-center justify-between text-xs">
                  <span class="text-gray-500">${item.timeAgo}</span>
                  <span class="${riskInfo.class}">${item.score}% risk</span>
                </div>
              </a>
            </li>
          `;
          }).join('');

          // Add click handlers to history items
          document.querySelectorAll('.security-history-item').forEach(item => {
            item.addEventListener('click', function () {
              const itemId = parseInt(this.dataset.itemId);
              showHistoryDetails(itemId);
            });
          });
        };

        // Helper function for risk info (needs to be accessible)
        function getRiskInfo(score) {
          if (score >= 80) return { color: '#ef4444', description: 'Very High Risk', class: 'text-red-400' };
          if (score >= 60) return { color: '#f97316', description: 'High Risk', class: 'text-orange-400' };
          if (score >= 40) return { color: '#eab308', description: 'Medium Risk', class: 'text-yellow-400' };
          if (score >= 20) return { color: '#06b6d4', description: 'Low Risk', class: 'text-cyan-400' };
          return { color: '#22c55e', description: 'Very Low Risk', class: 'text-green-400' };
        }

        // Show detailed view of history item
        function showHistoryDetails(itemId) {
          const item = window.promptInjectionState.history.find(h => h.id === itemId);
          if (!item) return;

          // Populate the main prompt input with the historical prompt
          const promptInput = document.getElementById('mainPromptInput');
          if (promptInput) {
            promptInput.value = item.fullPrompt;

            // Show results from history
            const resultsSection = document.getElementById('resultsSection');
            const scoreValue = document.getElementById('scoreValue');
            const scoreBar = document.getElementById('scoreBar');
            const scoreDescription = document.getElementById('scoreDescription');
            const patternsList = document.getElementById('patternsList');

            if (resultsSection && scoreValue && scoreBar && scoreDescription) {
              const riskInfo = getRiskInfo(item.score);

              scoreValue.textContent = item.score + '%';
              scoreValue.className = `text-2xl font-bold ${riskInfo.class}`;
              scoreBar.style.width = item.score + '%';
              scoreBar.style.backgroundColor = riskInfo.color;
              scoreDescription.textContent = riskInfo.description;
              scoreDescription.className = `text-sm ${riskInfo.class}`;

              // Display historical patterns
              if (patternsList) {
                if (item.heuristics && item.heuristics.length > 0) {
                  patternsList.innerHTML = item.heuristics.map(pattern => `
                  <div class="p-3 rounded-lg bg-red-500/10 border border-red-500/20 flex items-start gap-3">
                    <span class="material-icons text-red-400 text-[18px] flex-shrink-0 mt-0.5">warning</span>
                    <div class="flex-1">
                      <div class="text-red-400 font-medium text-sm">Security Pattern Detected</div>
                      <div class="text-gray-300 text-sm mt-1">${pattern}</div>
                    </div>
                  </div>
                `).join('');
                } else {
                  patternsList.innerHTML = `
                  <div class="p-3 rounded-lg bg-green-500/10 border border-green-500/20 flex items-start gap-3">
                    <span class="material-icons text-green-400 text-[18px] flex-shrink-0 mt-0.5">check_circle</span>
                    <div class="flex-1">
                      <div class="text-green-400 font-medium text-sm">No Suspicious Patterns</div>
                      <div class="text-gray-300 text-sm mt-1">No known injection patterns detected in this prompt</div>
                    </div>
                  </div>
                `;
                }
              }

              resultsSection.classList.remove('hidden');

              // Clear explanation section for historical data
              const explanationText = document.getElementById('explanationText');
              const explanationLoading = document.getElementById('explanationLoading');
              if (explanationText && explanationLoading) {
                explanationLoading.classList.add('hidden');
                explanationText.classList.remove('hidden');
                explanationText.innerHTML = '<div class="text-gray-400 text-sm italic">Run analysis again to get fresh AI explanation</div>';
              }
            }
          }
        }

        // Clear all history
        async function clearAllHistory() {
          if (!confirm('Are you sure you want to clear all security history? This action cannot be undone.')) {
            return;
          }

          // Clear local storage
          window.promptInjectionState.history = [];
          localStorage.setItem('securityHistory', JSON.stringify([]));
          updateSecurityHistoryDisplay();

          // Clear from Supabase
          if (window.promptInjectionSupabase) {
            try {
              const userId = await window.promptInjectionSupabase.getCurrentUserId?.();
              if (userId) {
                const client = window.promptInjectionSupabase.getClient?.();
                if (client) {
                  const { error } = await client
                    .from('Injections')
                    .delete()
                    .eq('user_id', userId);

                  if (error) {
                    console.error('Failed to clear injections from Supabase:', error);
                  } else {
                    console.log(' Injections cleared from Supabase');
                  }
                }
              }
            } catch (err) {
              console.warn('Failed to clear Supabase history:', err);
            }
          }
        }

        // Search functionality
        let searchTimeout;
        function handleHistorySearch() {
          clearTimeout(searchTimeout);
          searchTimeout = setTimeout(() => {
            updateSecurityHistoryDisplay();
          }, 300);
        }

        // Sync with Supabase
        async function syncWithSupabase() {
          if (!window.promptInjectionSupabase) {
            alert('Supabase integration not available');
            return;
          }

          // Show loading state
          const originalIcon = syncHistoryBtn.querySelector('.material-icons').textContent;
          syncHistoryBtn.querySelector('.material-icons').textContent = 'sync';
          syncHistoryBtn.classList.add('animate-spin');
          syncHistoryBtn.disabled = true;

          try {
            await window.promptInjectionSupabase.sync();
            console.log(' Manual sync completed');
          } catch (error) {
            console.error('Sync failed:', error);
            alert('Failed to sync with Supabase');
          } finally {
            // Restore button state
            syncHistoryBtn.querySelector('.material-icons').textContent = originalIcon;
            syncHistoryBtn.classList.remove('animate-spin');
            syncHistoryBtn.disabled = false;
          }
        }

        // Event listeners
        clearHistoryBtn.addEventListener('click', clearAllHistory);
        syncHistoryBtn.addEventListener('click', syncWithSupabase);
        historySearch.addEventListener('input', handleHistorySearch);

        // Initialize display
        window.updateSecurityHistoryDisplay();

      })();

      // Security Chat with n8n Webhook (via Flask proxy)
      (function () {
        'use strict';

        // Configuration - use local proxy to avoid CORS issues
        // This endpoint should proxy requests to Google Gemini (server-side) so keys remain secret.

        // Event listeners






      })();
    </script>

    <!-- Chat Search Functionality -->
    <script>
      (function () {
        'use strict';

        // Configuration
        const DEBOUNCE_DELAY = 200; // milliseconds

        // DOM elements
        const searchInput = document.getElementById('blockSearch');
        const chatList = document.getElementById('chatList');
        const resultsLive = document.getElementById('resultsLive');
        const noResults = document.getElementById('noResults');

        if (!searchInput || !chatList || !resultsLive || !noResults) {
          console.warn('Search elements not found');
          return;
        }

        // Cache for performance
        let blocksCache = [];
        let debounceTimer = null;

        /**
         * Normalize text for search (remove diacritics, trim, lowercase)
         */
        function normalizeText(text) {
          return text
            .trim()
            .toLowerCase()
            .normalize('NFD')
            .replace(/[\u0300-\u036f]/g, ''); // Remove diacritics
        }

        /**
         * Highlight matched text with <mark> tags
         */
        function highlightText(text, query) {
          if (!query) return text;

          const normalizedText = normalizeText(text);
          const normalizedQuery = normalizeText(query);

          if (!normalizedText.includes(normalizedQuery)) return text;

          // Find the original text position to highlight
          const regex = new RegExp(`(${query.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})`, 'gi');
          return text.replace(regex, '<mark>$1</mark>');
        }

        /**
         * Initialize blocks cache
         */
        function initializeCache() {
          const listItems = chatList.querySelectorAll('li');
          blocksCache = [];

          listItems.forEach((li, index) => {
            const titleElement = li.querySelector('.block-title, p');
            if (titleElement) {
              const originalTitle = titleElement.getAttribute('data-title') || titleElement.textContent;
              blocksCache.push({
                el: li,
                titleElement: titleElement,
                originalTitle: originalTitle,
                titleTextNormalized: normalizeText(originalTitle)
              });
            }
          });

          console.log(`Initialized cache with ${blocksCache.length} blocks`);
        }

        /**
         * Filter blocks based on search query
         */
        function filterBlocks(query) {
          const normalizedQuery = normalizeText(query);
          let visibleCount = 0;

          blocksCache.forEach(block => {
            const matches = !normalizedQuery || block.titleTextNormalized.includes(normalizedQuery);

            if (matches) {
              block.el.classList.remove('hidden');
              // Highlight matching text
              if (normalizedQuery) {
                block.titleElement.innerHTML = highlightText(block.originalTitle, query);
              } else {
                block.titleElement.innerHTML = block.originalTitle;
              }
              visibleCount++;
            } else {
              block.el.classList.add('hidden');
            }
          });

          // Handle no results state
          if (visibleCount === 0 && normalizedQuery) {
            noResults.classList.remove('hidden');
          } else {
            noResults.classList.add('hidden');
          }

          // Update ARIA live region
          if (normalizedQuery) {
            resultsLive.textContent = `${visibleCount} result${visibleCount !== 1 ? 's' : ''}`;
          } else {
            resultsLive.textContent = '';
          }

          return visibleCount;
        }

        /**
         * Debounced search handler
         */
        function handleSearch() {
          if (debounceTimer) {
            clearTimeout(debounceTimer);
          }

          debounceTimer = setTimeout(() => {
            const query = searchInput.value;
            filterBlocks(query);
          }, DEBOUNCE_DELAY);
        }

        /**
         * Initialize search functionality
         */
        function initSearch() {
          // Initialize cache
          initializeCache();

          // Add event listener
          searchInput.addEventListener('input', handleSearch);

          // Handle paste events
          searchInput.addEventListener('paste', () => {
            setTimeout(handleSearch, 10);
          });

          console.log('Chat search initialized');
        }

        // Initialize when DOM is ready
        if (document.readyState === 'loading') {
          document.addEventListener('DOMContentLoaded', initSearch);
        } else {
          initSearch();
        }

        // Re-initialize cache if content changes (for dynamic content)
        const observer = new MutationObserver(() => {
          initializeCache();
        });

        observer.observe(chatList, {
          childList: true,
          subtree: true
        });

      })();
    </script>

    <!-- AI Assistant Mode Selector -->
    <script>
      (function () {
        'use strict';

        const askModeBtn = document.getElementById('askMode');
        const agentModeBtn = document.getElementById('agentMode');
        const pillSlider = document.getElementById('pillSlider');

        if (!askModeBtn || !agentModeBtn || !pillSlider) {
          console.warn('Mode selector elements not found');
          return;
        }

        let currentMode = 'ask'; // Default mode

        /**
         * Update button styles and slider position based on selected mode
         */
        function updateModeStyles(selectedMode) {
          const buttons = [askModeBtn, agentModeBtn];

          // Update slider position
          if (selectedMode === 'ask') {
            pillSlider.style.transform = 'translateX(0)';
          } else if (selectedMode === 'agent') {
            pillSlider.style.transform = 'translateX(100%)';
          }

          // Update button text colors
          buttons.forEach(button => {
            const isSelected = button.dataset.mode === selectedMode;

            if (isSelected) {
              // Selected state - dark text for contrast with teal background
              button.className = 'mode-pill flex-1 px-3 py-1.5 text-sm font-medium rounded-full transition-all duration-200 relative z-10 text-black';
            } else {
              // Unselected state - light text
              button.className = 'mode-pill flex-1 px-3 py-1.5 text-sm font-medium rounded-full transition-all duration-200 relative z-10 text-gray-300 hover:text-white';
            }
          });

          currentMode = selectedMode;

          // Optional: Dispatch custom event for other parts of the app to listen to
          window.dispatchEvent(new CustomEvent('aiModeChanged', {
            detail: { mode: selectedMode }
          }));

          console.log(`AI Assistant mode changed to: ${selectedMode}`);
        }

        /**
         * Handle mode selection
         */
        function selectMode(mode) {
          if (mode !== currentMode) {
            updateModeStyles(mode);

            // Add any additional mode-specific logic here
            if (mode === 'ask') {
              // Configure for Ask mode - single questions
              console.log('Switched to Ask mode - optimized for single questions');
            } else if (mode === 'agent') {
              // Configure for Agent mode - multi-turn conversations
              console.log('Switched to Agent mode - optimized for extended conversations');
            }
          }
        }

        // Event listeners
        askModeBtn.addEventListener('click', () => selectMode('ask'));
        agentModeBtn.addEventListener('click', () => selectMode('agent'));

        // Initialize with default mode
        updateModeStyles(currentMode);

        console.log('AI Assistant mode selector initialized with sliding animation');

      })();
    </script>

    <!-- AI Assistant Collapse/Expand Functionality -->
    <script>
      (function () {
        'use strict';

        // Configuration
        const STORAGE_KEY = 'assistantCollapsed';

        // DOM elements
        const assistantPanel = document.getElementById('assistant-panel');
        const assistantContent = document.getElementById('assistant-content');
        const collapsedRail = document.getElementById('collapsed-rail');
        const collapseToggle = document.getElementById('assistant-toggle');
        const expandToggle = document.getElementById('expand-toggle');
        const editorPane = document.getElementById('editor-pane');

        if (!assistantPanel || !assistantContent || !collapsedRail || !collapseToggle || !expandToggle || !editorPane) {
          console.warn('Assistant collapse elements not found');
          return;
        }

        let isCollapsed = false;

        /**
         * Update panel state and styling
         */
        function updatePanelState(collapsed, animate = true) {
          isCollapsed = collapsed;

          if (collapsed) {
            // Collapsed state
            assistantPanel.classList.remove('w-72', 'md:w-80');
            assistantPanel.classList.add('w-7');
            assistantContent.classList.add('opacity-0', 'pointer-events-none');
            collapsedRail.classList.remove('hidden');

            // Update ARIA
            collapseToggle.setAttribute('aria-expanded', 'false');
            expandToggle.setAttribute('aria-expanded', 'false');
          } else {
            // Expanded state
            assistantPanel.classList.remove('w-7');
            assistantPanel.classList.add('w-72', 'md:w-80');
            assistantContent.classList.remove('opacity-0', 'pointer-events-none');
            collapsedRail.classList.add('hidden');

            // Update ARIA
            collapseToggle.setAttribute('aria-expanded', 'true');
            expandToggle.setAttribute('aria-expanded', 'true');
          }

          // Update tooltips
          collapseToggle.title = collapsed ? 'Expand assistant' : 'Collapse assistant';

          // Handle edge case: both panels collapsed
          handleBothPanelsCollapsed();

          // Save state to localStorage
          localStorage.setItem(STORAGE_KEY, collapsed.toString());

          // Trigger editor resize after animation completes
          if (animate) {
            setTimeout(() => {
              triggerEditorResize();
            }, 300); // Match transition duration
          } else {
            triggerEditorResize();
          }

          console.log(`Assistant panel ${collapsed ? 'collapsed' : 'expanded'}`);
        }

        /**
         * Handle the edge case when both panels are collapsed
         */
        function handleBothPanelsCollapsed() {
          const isHistoryCollapsed = localStorage.getItem('historyCollapsed') === 'true';

          if (isCollapsed && isHistoryCollapsed) {
            // Both panels collapsed - editor takes full width
            editorPane.classList.add('mx-4'); // Add margin to prevent edge-to-edge
            console.log('Both panels collapsed - editor at maximum width');
          } else {
            // At least one panel is expanded
            editorPane.classList.remove('mx-4');
          }
        }

        /**
         * Trigger editor resize (for code editors that need explicit resize)
         */
        function triggerEditorResize() {
          // Dispatch custom event for editor to listen to
          window.dispatchEvent(new CustomEvent('assistantPanelToggled', {
            detail: { collapsed: isCollapsed }
          }));

          // If using a code editor like CodeMirror/Monaco, call resize here
          // Example: if (window.editorInstance) window.editorInstance.layout();
        }

        /**
         * Toggle panel state
         */
        function togglePanel() {
          updatePanelState(!isCollapsed);
        }

        /**
         * Handle keyboard events
         */
        function handleKeydown(event) {
          if (event.key === 'Escape' && !isCollapsed) {
            updatePanelState(true);
            event.preventDefault();
          }

          if ((event.key === 'Enter' || event.key === ' ') &&
            (event.target === collapseToggle || event.target === expandToggle)) {
            togglePanel();
            event.preventDefault();
          }
        }

        /**
         * Initialize panel state from localStorage
         */
        function initializeState() {
          const storedState = localStorage.getItem(STORAGE_KEY);
          const shouldBeCollapsed = storedState === 'true';

          // Set initial state without animation on page load
          updatePanelState(shouldBeCollapsed, false);
        }

        // Event listeners
        collapseToggle.addEventListener('click', togglePanel);
        expandToggle.addEventListener('click', togglePanel);
        document.addEventListener('keydown', handleKeydown);

        // Listen for history panel changes
        window.addEventListener('historyPanelToggled', handleBothPanelsCollapsed);

        // Initialize state from localStorage
        initializeState();

        console.log('AI Assistant collapse/expand functionality initialized');

      })();
    </script>

    <!-- History Panel Collapse/Expand Functionality -->
    <script>
      (function () {
        'use strict';

        // Configuration
        const HISTORY_STORAGE_KEY = 'historyCollapsed';
        const ASSISTANT_STORAGE_KEY = 'assistantCollapsed';

        // DOM elements
        const historyPanel = document.getElementById('history-panel');
        const historyContent = document.getElementById('history-content');
        const historyCollapsedRail = document.getElementById('history-collapsed-rail');
        const historyCollapseToggle = document.getElementById('history-toggle');
        const historyExpandToggle = document.getElementById('history-expand-toggle');
        const editorPane = document.getElementById('editor-pane');
        const assistantPanel = document.getElementById('assistant-panel');

        if (!historyPanel || !historyContent || !historyCollapsedRail || !historyCollapseToggle || !historyExpandToggle) {
          console.warn('History collapse elements not found');
          return;
        }

        let isHistoryCollapsed = false;

        /**
         * Update history panel state and handle both panels edge case
         */
        function updateHistoryState(collapsed, animate = true) {
          isHistoryCollapsed = collapsed;

          if (collapsed) {
            // Collapsed state
            historyPanel.classList.remove('w-60', 'md:w-64');
            historyPanel.classList.add('w-7');
            historyContent.classList.add('opacity-0', 'pointer-events-none');
            historyCollapsedRail.classList.remove('hidden');

            // Update ARIA
            historyCollapseToggle.setAttribute('aria-expanded', 'false');
            historyExpandToggle.setAttribute('aria-expanded', 'false');
          } else {
            // Expanded state
            historyPanel.classList.remove('w-7');
            historyPanel.classList.add('w-60', 'md:w-64');
            historyContent.classList.remove('opacity-0', 'pointer-events-none');
            historyCollapsedRail.classList.add('hidden');

            // Update ARIA
            historyCollapseToggle.setAttribute('aria-expanded', 'true');
            historyExpandToggle.setAttribute('aria-expanded', 'true');
          }

          // Update tooltips
          historyCollapseToggle.title = collapsed ? 'Expand history' : 'Collapse history';

          // Handle edge case: both panels collapsed
          handleBothPanelsCollapsed();

          // Save state to localStorage
          localStorage.setItem(HISTORY_STORAGE_KEY, collapsed.toString());

          // Trigger editor resize after animation completes
          if (animate) {
            setTimeout(() => {
              triggerEditorResize();
            }, 300); // Match transition duration
          } else {
            triggerEditorResize();
          }

          console.log(`History panel ${collapsed ? 'collapsed' : 'expanded'}`);
        }

        /**
         * Handle the edge case when both panels are collapsed
         */
        function handleBothPanelsCollapsed() {
          const isAssistantCollapsed = localStorage.getItem(ASSISTANT_STORAGE_KEY) === 'true';

          if (isHistoryCollapsed && isAssistantCollapsed) {
            // Both panels collapsed - editor takes full width
            editorPane.classList.add('mx-4'); // Add margin to prevent edge-to-edge
            console.log('Both panels collapsed - editor at maximum width');
          } else {
            // At least one panel is expanded
            editorPane.classList.remove('mx-4');
          }
        }

        /**
         * Trigger editor resize (for code editors that need explicit resize)
         */
        function triggerEditorResize() {
          // Dispatch custom event for editor to listen to
          window.dispatchEvent(new CustomEvent('historyPanelToggled', {
            detail: {
              historyCollapsed: isHistoryCollapsed,
              assistantCollapsed: localStorage.getItem(ASSISTANT_STORAGE_KEY) === 'true'
            }
          }));
        }

        /**
         * Toggle history panel state
         */
        function toggleHistoryPanel() {
          updateHistoryState(!isHistoryCollapsed);
        }

        /**
         * Handle keyboard events
         */
        function handleHistoryKeydown(event) {
          if (event.key === 'Escape' && !isHistoryCollapsed) {
            updateHistoryState(true);
            event.preventDefault();
          }

          if ((event.key === 'Enter' || event.key === ' ') &&
            (event.target === historyCollapseToggle || event.target === historyExpandToggle)) {
            toggleHistoryPanel();
            event.preventDefault();
          }
        }

        /**
         * Initialize history panel state from localStorage
         */
        function initializeHistoryState() {
          const storedState = localStorage.getItem(HISTORY_STORAGE_KEY);
          const shouldBeCollapsed = storedState === 'true';

          // Set initial state without animation on page load
          updateHistoryState(shouldBeCollapsed, false);
        }

        /**
         * Listen for assistant panel changes to handle both-collapsed edge case
         */
        function handleAssistantPanelChange() {
          handleBothPanelsCollapsed();
        }

        // Event listeners
        historyCollapseToggle.addEventListener('click', toggleHistoryPanel);
        historyExpandToggle.addEventListener('click', toggleHistoryPanel);
        document.addEventListener('keydown', handleHistoryKeydown);

        // Listen for assistant panel changes
        window.addEventListener('assistantPanelToggled', handleAssistantPanelChange);

        // Initialize state from localStorage
        initializeHistoryState();

        console.log('History collapse/expand functionality initialized');

      })();
    </script>

  </div> <!-- End main-content -->

  <!-- Chat History Management -->
  <script type="module">
    // Wait for the main auth script to initialize Supabase client
    // then reuse it to avoid multiple client instances

    // DOM elements
    const historyLoading = document.getElementById('history-loading');
    const historyError = document.getElementById('history-error');
    const historyEmptyAuth = document.getElementById('history-empty-auth');
    const historyEmptyChats = document.getElementById('history-empty-chats');
    const chatList = document.getElementById('chatList');
    const retryHistoryBtn = document.getElementById('retry-history-btn');
    const blockSearch = document.getElementById('blockSearch');

    let currentUser = null;
    let allChats = [];
    let filteredChats = [];
    let supabaseClientForHistory = null;

    // Get Supabase client from window (shared with main auth script)
    function getSupabaseClient() {
      if (window.supabaseClient) {
        return window.supabaseClient;
      }

      // Fallback: create our own client if not available
      const { createClient } = supabase;
      const supabaseUrl = 'https://qnbvnczctgbclolvkjcb.supabase.co';
      const supabaseKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InFuYnZuY3pjdGdiY2xvbHZramNiIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjI1NTg3NDIsImV4cCI6MjA3ODEzNDc0Mn0.v5t8eMJjpPtdIn6oKXshjuIH0shlztIp9fWBrRjnrGg';
      return createClient(supabaseUrl, supabaseKey);
    }

    // Show specific state and hide others
    function showHistoryState(state) {
      historyLoading.classList.add('hidden');
      historyError.classList.add('hidden');
      historyEmptyAuth.classList.add('hidden');
      historyEmptyChats.classList.add('hidden');
      chatList.classList.add('hidden');

      switch (state) {
        case 'loading':
          historyLoading.classList.remove('hidden');
          break;
        case 'error':
          historyError.classList.remove('hidden');
          break;
        case 'empty-auth':
          historyEmptyAuth.classList.remove('hidden');
          break;
        case 'empty-chats':
          historyEmptyChats.classList.remove('hidden');
          break;
        case 'data':
          chatList.classList.remove('hidden');
          break;
      }
    }

    // Load chat history from Supabase
    async function loadChatHistory() {
      if (!currentUser) {
        showHistoryState('empty-auth');
        return;
      }

      // Get the shared Supabase client
      supabaseClientForHistory = getSupabaseClient();

      if (!supabaseClientForHistory) {
        console.error('Supabase client not available');
        showHistoryState('error');
        return;
      }

      showHistoryState('loading');

      try {
        // Debug: Let's see what columns are actually available
        console.log('Attempting to load chat history for user:', currentUser.id);

        // First, try a simple select to see what happens
        let { data, error } = await supabaseClientForHistory
          .from('Chats')
          .select('*')
          .eq('user_id', currentUser.id)
          .limit(5);

        console.log('Initial query result:', { data, error });

        if (error) {
          console.log('Error occurred, trying alternative approaches...');

          if (error.code === '42703') {
            // Column doesn't exist, let's try common column name variations
            console.log('Trying alternative column names...');

            // Try different possible column names for content
            const contentColumns = ['content', 'message', 'body', 'description', 'prompt', 'chat_content', 'conversation', 'prompt_text'];
            let workingQuery = null;

            for (const contentCol of contentColumns) {
              try {
                console.log(`Trying column: ${contentCol}`);
                const testResult = await supabaseClientForHistory
                  .from('Chats')
                  .select(`id, title, ${contentCol}, user_id, created_at`)
                  .eq('user_id', currentUser.id)
                  .limit(1);

                console.log(`Result for ${contentCol}:`, testResult);

                if (!testResult.error) {
                  workingQuery = contentCol;
                  console.log(`Found working column: ${contentCol}`);
                  break;
                }
              } catch (e) {
                console.log(`Column ${contentCol} failed:`, e);
                // Continue to next column name
              }
            }

            if (workingQuery) {
              // Use the working column name
              const result = await supabaseClientForHistory
                .from('Chats')
                .select(`id, title, ${workingQuery}, user_id, created_at`)
                .eq('user_id', currentUser.id)
                .order('created_at', { ascending: false });

              data = result.data;
              error = result.error;

              // Map the working column to 'text' for consistency while preserving original data
              if (data) {
                data = data.map(chat => ({
                  ...chat, // Keep all original columns
                  text: chat[workingQuery] || 'No content available' // Add text for preview
                }));
              }
            } else {
              // If no content column found, just get basic columns without content
              console.log('No content column found, getting basic columns only');
              const result = await supabaseClientForHistory
                .from('Chats')
                .select('id, title, user_id, created_at')
                .eq('user_id', currentUser.id)
                .order('created_at', { ascending: false });

              data = result.data;
              error = result.error;

              // Add placeholder text while preserving original data
              if (data) {
                data = data.map(chat => ({
                  ...chat, // Keep all original columns
                  text: 'Content column not found' // Add text for preview
                }));
              }
            }
          } else {
            // Some other error
            console.error('Other error occurred:', error);
            showHistoryState('error');
            return;
          }
        } else {
          // The select * worked, so let's use it but normalize the data
          console.log('Select * worked, normalizing data...');
          if (data && data.length > 0) {
            // Look at the first row to see what columns we have
            const firstRow = data[0];
            const availableColumns = Object.keys(firstRow);
            console.log('Available columns:', availableColumns);

            // Find a content column
            const contentColumn = availableColumns.find(col =>
              ['text', 'content', 'message', 'body', 'description', 'prompt', 'chat_content', 'conversation'].includes(col.toLowerCase())
            );

            // Map to standardized format while preserving original data
            if (contentColumn) {
              console.log('Using content column:', contentColumn);
              // Map to standardized format but keep original columns
              data = data.map(chat => ({
                ...chat, // Keep all original columns
                text: chat[contentColumn] || 'No content' // Add text for preview
              }));
            } else {
              console.log('No recognized content column found');
              // Add placeholder but keep original data
              data = data.map(chat => ({
                ...chat, // Keep all original columns
                text: 'Content column not found' // Add text for preview
              }));
            }
          }

          // Get full data with proper ordering
          const result = await supabaseClientForHistory
            .from('Chats')
            .select('*')
            .eq('user_id', currentUser.id)
            .order('created_at', { ascending: false });

          data = result.data;
          error = result.error;
        }

        console.log('Final data:', data);
        console.log('Final error:', error);

        if (error) {
          console.error('Error loading chat history:', error);
          showHistoryState('error');
          return;
        }

        allChats = data || [];
        filteredChats = [...allChats];

        if (allChats.length === 0) {
          console.log('No chats found, showing empty state');
          showHistoryState('empty-chats');
        } else {
          console.log(`Found ${allChats.length} chats, rendering...`);
          renderChatHistory(filteredChats);
          showHistoryState('data');
        }
      } catch (error) {
        console.error('Failed to load chat history:', error);
        showHistoryState('error');
      }
    }

    // Create preview text from chat content
    function createPreview(text, maxLength = 60) {
      if (!text) return 'No preview available';

      // Strip HTML tags if present and get plain text
      const plainText = text.replace(/<[^>]*>/g, '').trim();

      if (plainText.length <= maxLength) return plainText;

      // Find the last space before maxLength to avoid cutting words
      const truncated = plainText.substring(0, maxLength);
      const lastSpace = truncated.lastIndexOf(' ');

      if (lastSpace > maxLength * 0.7) {
        return truncated.substring(0, lastSpace) + '...';
      }

      return truncated + '...';
    }

    // Render chat history items
    function renderChatHistory(chats) {
      chatList.innerHTML = '';

      chats.forEach((chat, index) => {
        const li = document.createElement('li');
        const isSelected = index === 0; // First item selected by default

        li.innerHTML = `
          <a class="block p-3 rounded-2xl bg-transparent hover:bg-white/5 border border-transparent hover:border-white/10 transition focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-lime-300/40"
            href="#" 
            data-chat-id="${chat.id}" 
            ${isSelected ? 'data-selected="true"' : ''}>
            <p class="block-title font-${isSelected ? 'semibold' : 'medium'} text-white truncate text-base" 
               data-title="${chat.title || 'Untitled Chat'}">
              ${chat.title || 'Untitled Chat'}
            </p>
            <p class="text-[13px] text-gray-400 line-clamp-2 mt-0.5">
              ${createPreview(chat.text)}
            </p>
          </a>
        `;

        // Add click handler for chat selection
        const link = li.querySelector('a');
        link.addEventListener('click', (e) => {
          e.preventDefault();
          selectChat(chat);
        });

        chatList.appendChild(li);
      });
    }

    // Handle chat selection
    function selectChat(chat) {
      // Remove selection from all items
      chatList.querySelectorAll('a').forEach(link => {
        link.removeAttribute('data-selected');
        const title = link.querySelector('.block-title');
        title.className = title.className.replace('font-semibold', 'font-medium');
      });

      // Add selection to clicked item
      const selectedLink = chatList.querySelector(`a[data-chat-id="${chat.id}"]`);
      if (selectedLink) {
        selectedLink.setAttribute('data-selected', 'true');
        const title = selectedLink.querySelector('.block-title');
        title.className = title.className.replace('font-medium', 'font-semibold');
      }

      // Load the chat content into the main editor
      loadChatContent(chat);
      console.log('Selected chat:', chat);
    }

    // Load chat content into the main text editor
    function loadChatContent(chat) {
      const textEditor = document.getElementById('textEditor');
      const formattedEditor = document.getElementById('formattedEditor');

      // Only load into legacy text editor if formatted editor is not being used
      if (textEditor && chat && !formattedEditor.classList.contains('hidden')) {
        console.log('Skipping chat content load - using formatted editor for AI responses only');
        return;
      }

      if (textEditor && chat) {
        // Use the content from the chat, fallback to text if content doesn't exist
        let content = chat.content || chat.text || chat.message || 'No content available';

        // If content is the mapped text from our query, try to get original content
        if (content === 'Content column not found' || content === 'No content available') {
          // Try to find the actual content in the chat object
          const possibleContentKeys = ['content', 'message', 'body', 'description', 'prompt', 'chat_content', 'conversation', 'prompt_text'];
          for (const key of possibleContentKeys) {
            if (chat[key] && chat[key] !== content) {
              content = chat[key];
              break;
            }
          }
        }

        textEditor.value = content;

        // Update the editor title if there's a title element
        const editorTitle = document.querySelector('#editor-pane h1');
        if (editorTitle && chat.title) {
          editorTitle.textContent = chat.title;
        }

        // Trigger any change events that might be needed
        textEditor.dispatchEvent(new Event('input', { bubbles: true }));

        console.log('Loaded content into editor:', content.substring(0, 100) + '...');
      }
    }

    // Filter chats based on search
    function filterChats(searchTerm) {
      if (!searchTerm.trim()) {
        filteredChats = [...allChats];
      } else {
        const term = searchTerm.toLowerCase();
        filteredChats = allChats.filter(chat =>
          (chat.title && chat.title.toLowerCase().includes(term)) ||
          (chat.text && chat.text.toLowerCase().includes(term))
        );
      }

      if (filteredChats.length === 0 && allChats.length > 0) {
        // Show "no results" message
        chatList.innerHTML = `
          <li class="p-4 text-center">
            <p class="text-gray-400 text-sm">No chats found matching your search</p>
          </li>
        `;
        chatList.classList.remove('hidden');
      } else if (filteredChats.length > 0) {
        renderChatHistory(filteredChats);
        showHistoryState('data');
      } else {
        showHistoryState(currentUser ? 'empty-chats' : 'empty-auth');
      }
    }

    // Set up real-time subscription for chat updates
    function setupRealtimeSubscription() {
      if (!currentUser) return;

      const client = getSupabaseClient();
      if (!client) return;

      const subscription = client
        .channel('chat-changes')
        .on('postgres_changes',
          {
            event: '*',
            schema: 'public',
            table: 'Chats',
            filter: `user_id=eq.${currentUser.id}`
          },
          (payload) => {
            console.log('Chat update:', payload);
            // Reload chat history when changes occur
            loadChatHistory();
          }
        )
        .subscribe();

      // Store subscription for cleanup
      window.chatSubscription = subscription;
    }

    // Initialize history for authenticated user
    function initializeHistory(user) {
      currentUser = user;
      loadChatHistory();
      setupRealtimeSubscription();
    }

    // Reset history for unauthenticated state
    function resetHistory() {
      currentUser = null;
      allChats = [];
      filteredChats = [];

      // Cleanup subscription
      if (window.chatSubscription) {
        const client = getSupabaseClient();
        if (client) {
          client.removeChannel(window.chatSubscription);
        }
        window.chatSubscription = null;
      }

      showHistoryState('empty-auth');
    }

    // Event listeners
    retryHistoryBtn.addEventListener('click', loadChatHistory);

    // Search functionality
    blockSearch.addEventListener('input', (e) => {
      filterChats(e.target.value);
    });

    // Initialize when page loads
    document.addEventListener('DOMContentLoaded', () => {
      // Wait a bit for the main auth script to initialize
      setTimeout(() => {
        const client = getSupabaseClient();
        if (client) {
          // Listen for auth state changes from the main auth script
          client.auth.onAuthStateChange((event, session) => {
            if (session?.user) {
              initializeHistory(session.user);
            } else {
              resetHistory();
            }
          });

          // Initial check for current session
          client.auth.getSession().then(({ data: { session } }) => {
            if (session?.user) {
              initializeHistory(session.user);
            } else {
              resetHistory();
            }
          });
        }
      }, 500); // Small delay to ensure main auth script loads first
    });
  </script>

  <!-- Auth & Profile Management -->
  <script type="module">
    // Initialize Supabase
    const { createClient } = supabase;
    const supabaseUrl = 'https://qnbvnczctgbclolvkjcb.supabase.co';
    const supabaseKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InFuYnZuY3pjdGdiY2xvbHZramNiIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjI1NTg3NDIsImV4cCI6MjA3ODEzNDc0Mn0.v5t8eMJjpPtdIn6oKXshjuIH0shlztIp9fWBrRjnrGg';
    const supabaseClient = createClient(supabaseUrl, supabaseKey);

    // Make supabase client available globally to avoid multiple instances
    window.supabaseClient = supabaseClient;

    // DOM elements
    const authLoading = document.getElementById('auth-loading');
    const mainContent = document.getElementById('main-content');
    const profileInitials = document.getElementById('profile-initials');
    const profileEmail = document.getElementById('profile-email');
    const signOutBtn = document.getElementById('sign-out-btn');

    // Auth guard - check session on page load
    async function checkAuth() {
      try {
        const { data: { session }, error } = await supabaseClient.auth.getSession();

        if (error) {
          console.error('Auth error:', error);
          redirectToLogin();
          return;
        }

        if (!session) {
          redirectToLogin();
          return;
        }

        // User is authenticated
        showMainContent(session.user);
      } catch (error) {
        console.error('Auth check failed:', error);
        redirectToLogin();
      }
    }

    // Redirect to login page
    function redirectToLogin() {
      window.location.href = '/login_signup';
    }

    // Show main content and set up profile
    function showMainContent(user) {
      // Hide loading overlay
      authLoading.classList.add('hidden');

      // Show main content
      mainContent.classList.remove('hidden');

      // Set up profile icon
      setupProfile(user);
    }

    // Set up profile information
    function setupProfile(user) {
      // Set initials
      const email = user.email;
      const fullName = user.user_metadata?.full_name || email;

      let initials = '';
      if (fullName && fullName !== email) {
        // Extract initials from full name
        const nameParts = fullName.split(' ');
        initials = nameParts.map(part => part.charAt(0).toUpperCase()).join('');
        if (initials.length > 2) initials = initials.substring(0, 2);
      } else {
        // Use first character of email
        initials = email.charAt(0).toUpperCase();
      }

      profileInitials.textContent = initials;
      profileEmail.textContent = email;
      profileEmail.title = email; // Full email on hover
    }

    // Sign out handler
    async function handleSignOut() {
      try {
        const { error } = await supabaseClient.auth.signOut();

        if (error) {
          console.error('Sign out error:', error);
        }

        // Redirect to index page
        window.location.href = '/';
      } catch (error) {
        console.error('Sign out failed:', error);
        // Force redirect even if sign out fails
        window.location.href = '/';
      }
    }

    // Listen for auth state changes
    supabaseClient.auth.onAuthStateChange((event, session) => {
      if (event === 'SIGNED_OUT' || !session) {
        window.location.href = '/';
      }
    });

    // Event listeners
    signOutBtn.addEventListener('click', handleSignOut);

    // Initialize auth check
    checkAuth();
  </script>

  <!-- AI Chat Assistant Implementation -->
  <script>
    (() => {
      'use strict';

      // Chat state management
      class ChatManager {
        constructor() {
          this.messages = [];
          this.messageCounter = 0;
          this.isNearBottom = true;
          this.isTyping = false;
          this.scrollThreshold = 50;
          this.userHasScrolledUp = false;
          this.sessionId = null; // Will be generated on first message
          this.rawEditorContent = ''; // Store raw content for copy/download

          // DOM elements
          this.transcript = document.getElementById('chat-transcript');
          this.messageInput = document.getElementById('message-input');
          this.sendButton = document.getElementById('send-button');
          this.typingIndicator = document.getElementById('typing-indicator');
          this.errorToast = document.getElementById('error-toast');
          this.newMessagesNotification = document.getElementById('new-messages-notification');
          this.jumpToLatest = document.getElementById('jump-to-latest');

          // Bind methods
          this.handleSend = this.handleSend.bind(this);
          this.handleKeyDown = this.handleKeyDown.bind(this);
          this.handleInput = this.handleInput.bind(this);
          this.handleScroll = this.handleScroll.bind(this);
          this.handleJumpToLatest = this.handleJumpToLatest.bind(this);
          this.handleKeyboardNavigation = this.handleKeyboardNavigation.bind(this);
          this.scrollToBottom = this.scrollToBottom.bind(this);

          this.init();
        }

        init() {
          if (!this.transcript || !this.messageInput || !this.sendButton) {
            console.error('Chat: Required elements not found');
            return;
          }

          console.log('Chat: Initializing AI Assistant chat interface');

          // Set up event listeners
          this.sendButton.addEventListener('click', this.handleSend);
          this.messageInput.addEventListener('keydown', this.handleKeyDown);
          this.messageInput.addEventListener('input', this.handleInput);
          this.transcript.addEventListener('scroll', this.handleScroll);
          this.transcript.addEventListener('keydown', this.handleKeyboardNavigation);

          if (this.jumpToLatest) {
            this.jumpToLatest.addEventListener('click', this.handleJumpToLatest);
          }

          if (this.newMessagesNotification) {
            this.newMessagesNotification.addEventListener('click', this.handleJumpToLatest);
          }

          // Auto-resize textarea
          this.setupTextareaResize();

          // Load existing messages if any
          this.loadMessages();

          // Show welcome message if no messages exist
          if (this.messages.length === 0) {
            this.addWelcomeMessage();
          }

          // Focus input and ensure we're at bottom
          this.messageInput.focus();
          setTimeout(() => {
            this.checkScrollPosition();
            this.scrollToBottom(false);
            console.log('Chat: Mounted and scrolled to bottom');
          }, 100);

          console.log('Chat: AI Assistant chat interface initialized successfully');
        }

        setupTextareaResize() {
          this.messageInput.style.height = 'auto';

          const adjustHeight = () => {
            const maxHeight = 6 * 24; // 6 lines * 24px line height
            this.messageInput.style.height = 'auto';
            const scrollHeight = this.messageInput.scrollHeight;

            if (scrollHeight <= maxHeight) {
              this.messageInput.style.height = scrollHeight + 'px';
              this.messageInput.style.overflowY = 'hidden';
            } else {
              this.messageInput.style.height = maxHeight + 'px';
              this.messageInput.style.overflowY = 'auto';
            }
          };

          this.messageInput.addEventListener('input', adjustHeight);
          adjustHeight(); // Initial adjustment
        }

        handleSend() {
          const content = this.messageInput.value.trim();
          if (!content || this.isTyping) return;

          console.log('Chat: Sending user message');
          this.sendMessage(content);
        }

        handleKeyDown(event) {
          if (event.key === 'Enter') {
            if (event.shiftKey) {
              // Allow new line
              return;
            } else {
              // Send message
              event.preventDefault();
              this.handleSend();
            }
          }
        }

        handleKeyboardNavigation(event) {
          if (!this.transcript) return;

          const { scrollTop, scrollHeight, clientHeight } = this.transcript;
          const scrollAmount = clientHeight * 0.8; // 80% of visible area

          switch (event.key) {
            case 'PageUp':
              event.preventDefault();
              this.transcript.scrollTo({
                top: Math.max(0, scrollTop - scrollAmount),
                behavior: 'smooth'
              });
              console.log('Chat: User navigated up via PageUp');
              break;

            case 'PageDown':
              event.preventDefault();
              this.transcript.scrollTo({
                top: Math.min(scrollHeight - clientHeight, scrollTop + scrollAmount),
                behavior: 'smooth'
              });
              console.log('Chat: User navigated down via PageDown');
              break;

            case 'Home':
              if (event.ctrlKey) {
                event.preventDefault();
                this.transcript.scrollTo({
                  top: 0,
                  behavior: 'smooth'
                });
                console.log('Chat: User navigated to top via Ctrl+Home');
              }
              break;

            case 'End':
              if (event.ctrlKey) {
                event.preventDefault();
                this.scrollToBottom();
                console.log('Chat: User navigated to bottom via Ctrl+End');
              }
              break;
          }
        }

        handleInput() {
          const hasContent = this.messageInput.value.trim().length > 0;
          this.sendButton.disabled = !hasContent || this.isTyping;

          // Update button appearance
          if (hasContent && !this.isTyping) {
            this.sendButton.classList.remove('text-gray-400');
            this.sendButton.classList.add('text-gray-300');
          } else {
            this.sendButton.classList.add('text-gray-400');
            this.sendButton.classList.remove('text-gray-300');
          }
        }

        handleScroll() {
          this.checkScrollPosition();

          // Update user scroll state
          if (!this.isNearBottom && !this.userHasScrolledUp) {
            this.userHasScrolledUp = true;
            console.log('Chat: User scrolled up from bottom');
          }
        }

        checkScrollPosition() {
          if (!this.transcript) return;

          const { scrollTop, scrollHeight, clientHeight } = this.transcript;
          const distanceFromBottom = scrollHeight - scrollTop - clientHeight;
          const wasNearBottom = this.isNearBottom;

          this.isNearBottom = distanceFromBottom <= this.scrollThreshold;

          // Show/hide jump button
          if (this.isNearBottom) {
            this.hideJumpToLatest();
            if (this.userHasScrolledUp) {
              this.userHasScrolledUp = false;
              console.log('Chat: User returned to bottom');
            }
          } else if (!wasNearBottom && distanceFromBottom > this.scrollThreshold * 2) {
            // Only show jump button if user is significantly away from bottom
            this.showJumpToLatest();
          }

          // Hide new messages notification if user scrolls to bottom
          if (this.isNearBottom) {
            this.hideNewMessagesNotification();
          }
        }

        handleJumpToLatest() {
          console.log('Chat: User clicked jump to latest button');
          this.scrollToBottom();
          this.hideJumpToLatest();
        }

        scrollToBottom(smooth = true) {
          if (!this.transcript) return;

          // Use requestAnimationFrame to ensure DOM has updated
          requestAnimationFrame(() => {
            this.transcript.scrollTo({
              top: this.transcript.scrollHeight,
              behavior: smooth ? 'smooth' : 'auto'
            });

            // Update state after scroll
            setTimeout(() => {
              this.isNearBottom = true;
              this.userHasScrolledUp = false;
              this.hideNewMessagesNotification();
              this.hideJumpToLatest();

              if (smooth) {
                console.log('Chat: Auto-scrolled to latest message');
              }
            }, smooth ? 300 : 50);
          });
        }

        showJumpToLatest() {
          if (!this.jumpToLatest || !this.jumpToLatest.classList.contains('hidden')) return;

          this.jumpToLatest.classList.remove('hidden');
          console.log('Chat: Jump to latest button shown');
        }

        hideJumpToLatest() {
          if (!this.jumpToLatest || this.jumpToLatest.classList.contains('hidden')) return;

          // Add fade-out animation
          this.jumpToLatest.classList.add('fade-out');
          setTimeout(() => {
            this.jumpToLatest.classList.add('hidden');
            this.jumpToLatest.classList.remove('fade-out');
          }, 200);

          console.log('Chat: Jump to latest button hidden');
        }

        showNewMessagesNotification() {
          if (!this.isNearBottom && this.userHasScrolledUp) {
            this.newMessagesNotification.classList.remove('hidden');
            console.log('Chat: New messages notification shown');
          }
        }

        hideNewMessagesNotification() {
          this.newMessagesNotification.classList.add('hidden');
        }

        async sendMessage(content) {
          // Clear input and reset height
          this.messageInput.value = '';
          this.messageInput.style.height = 'auto';
          this.handleInput(); // Update button state
          this.hideError();

          // Add user message
          const userMessage = this.createMessage('user', content);
          this.addMessage(userMessage);

          // Show typing indicator
          this.showTyping();

          try {
            console.log('Chat: Sending message to AI Assistant API');

            // Generate session ID if needed
            if (!this.sessionId) {
              this.sessionId = 'session-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
            }

            const response = await fetch('/api/chat', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
              },
              body: JSON.stringify({
                message: content,
                session_id: this.sessionId
              }),
              signal: AbortSignal.timeout(60000) // 60 second timeout
            });

            if (!response.ok) {
              const errorData = await response.json().catch(() => ({}));
              throw new Error(errorData.error || `Server error: ${response.status}`);
            }

            const data = await response.json();
            console.log('Chat: Received AI response', data);

            // Hide typing indicator first
            this.hideTyping();

            // Extract response text from the API
            let aiResponse = data.reply || data.final_output;

            // Handle complex response objects
            if (typeof aiResponse === 'object' && aiResponse !== null) {
              aiResponse = aiResponse.text || aiResponse.content || aiResponse.response || JSON.stringify(aiResponse);
            }

            // Fallback if no response text found
            if (!aiResponse || aiResponse.trim().length === 0) {
              aiResponse = 'I processed your request, but I don\'t have a response to display right now.';
            }

            // Add AI response message
            const aiMessage = this.createMessage('ai', aiResponse);
            this.addMessage(aiMessage);

            console.log('Chat: AI response added successfully');

          } catch (error) {
            console.error('Chat: API Error:', error);

            // Hide typing indicator
            this.hideTyping();

            // Show error message in chat
            let errorMessage = 'I encountered an error processing your request. Please try again.';

            if (error.name === 'TimeoutError' || error.message.includes('timeout')) {
              errorMessage = 'The request timed out. Please try again with a shorter message.';
            } else if (error.message.includes('Failed to fetch')) {
              errorMessage = 'Unable to connect to the AI service. Please check your connection and try again.';
            }

            const errorAIMessage = this.createMessage('ai', errorMessage);
            this.addMessage(errorAIMessage);

            // Also show the error toast
            this.showError(error.message);
          }

          // Focus input after response/error
          setTimeout(() => {
            this.messageInput.focus();
          }, 100);
        }

        createMessage(role, content) {
          return {
            id: ++this.messageCounter,
            role,
            content,
            timestamp: new Date()
          };
        }

        addMessage(message) {
          this.messages.push(message);
          this.renderMessage(message);
          this.saveMessages();

          console.log(`Chat: New ${message.role} message added`, {
            messageId: message.id,
            isNearBottom: this.isNearBottom,
            userScrolledUp: this.userHasScrolledUp
          });

          // Update text editor with AI response content
          if (message.role === 'ai') {
            this.updateTextEditor(message.content);
          }

          // Auto-scroll if user is near bottom
          if (this.isNearBottom && !this.userHasScrolledUp) {
            setTimeout(() => this.scrollToBottom(), 100);
          } else if (this.userHasScrolledUp) {
            this.showNewMessagesNotification();
            this.showJumpToLatest();
            console.log('Chat: New message available, but user has scrolled up');
          }
        }

        renderMessage(message) {
          const messageElement = this.createMessageElement(message);
          this.transcript.appendChild(messageElement);

          // Trigger reflow to ensure proper scroll calculation
          this.transcript.offsetHeight;
        }

        createMessageElement(message) {
          const messageDiv = document.createElement('div');
          messageDiv.className = `message-${message.role}`;
          messageDiv.setAttribute('data-message-id', message.id);

          const timestamp = this.formatTimestamp(message.timestamp);
          const content = this.formatMessageContent(message.content);

          if (message.role === 'user') {
            messageDiv.innerHTML = `
              <div class="flex justify-end">
                <div class="bg-primary rounded-2xl p-3 max-w-[85%] shadow-md shadow-primary/20">
                  <div class="text-xs text-black/60 mb-1">You  ${timestamp}</div>
                  <div class="text-sm md:text-base text-black message-content">${content}</div>
                </div>
              </div>
            `;
          } else {
            messageDiv.innerHTML = `
              <div class="flex items-start gap-3">
                <div class="w-7 h-7 rounded-full bg-primary flex-shrink-0 grid place-items-center shadow-md shadow-primary/30">
                  <span class="material-icons text-black text-[18px]">auto_awesome</span>
                </div>
                <div class="bg-white/5 border border-white/10 rounded-2xl p-3 max-w-[85%]">
                  <div class="text-xs text-gray-400 mb-1">AI  ${timestamp}</div>
                  <div class="text-sm md:text-base text-gray-100 message-content">${content}</div>
                </div>
              </div>
            `;
          }

          return messageDiv;
        }

        formatMessageContent(content) {
          // Preserve line breaks and basic formatting
          return content
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&#39;')
            .replace(/\n/g, '<br>');
        }

        formatTimestamp(date) {
          return date.toLocaleTimeString('en-US', {
            hour: 'numeric',
            minute: '2-digit',
            hour12: true
          });
        }

        generateAIResponse(userContent) {
          const responses = [
            "I'd be happy to help you with that! Let me know if you need any clarification.",
            "That's an interesting point. Here's what I think about it...",
            "Great question! Based on your document, I can suggest a few improvements.",
            "I can help you enhance that section. Would you like me to provide some specific suggestions?",
            "Let me analyze that for you and provide some recommendations.",
            "That's a good approach! Here are some additional ideas you might consider.",
            "I understand what you're looking for. Let me provide some guidance on that.",
            "Excellent! I can definitely help you refine that further."
          ];

          // Simple response selection based on content
          const lowerContent = userContent.toLowerCase();

          if (lowerContent.includes('help') || lowerContent.includes('how')) {
            return "I'd be happy to help you with that! Can you provide more details about what you're trying to accomplish?";
          } else if (lowerContent.includes('improve') || lowerContent.includes('better')) {
            return "Great question! I can suggest several ways to improve that. What specific aspect would you like to focus on?";
          } else if (lowerContent.includes('write') || lowerContent.includes('create')) {
            return "I can definitely help you with writing! What type of content are you looking to create?";
          } else {
            return responses[Math.floor(Math.random() * responses.length)];
          }
        }

        addWelcomeMessage() {
          const welcomeMessage = this.createMessage('ai', 'Hello! I\'m your AI assistant. How can I help you with your document today?');
          this.addMessage(welcomeMessage);
          console.log('Chat: Welcome message added');
        }

        showTyping() {
          this.isTyping = true;
          this.typingIndicator.classList.remove('hidden');
          this.sendButton.disabled = true;
          this.handleInput(); // Update button state

          // Auto-scroll if near bottom
          if (this.isNearBottom && !this.userHasScrolledUp) {
            setTimeout(() => this.scrollToBottom(), 100);
          }

          console.log('Chat: AI typing indicator shown');
        }

        hideTyping() {
          this.isTyping = false;
          this.typingIndicator.classList.add('hidden');
          this.handleInput(); // Update button state

          console.log('Chat: AI typing indicator hidden');
        }

        showError(message = 'Failed to send message. Please try again.') {
          // Update error message
          this.errorToast.textContent = message;
          this.errorToast.classList.remove('hidden');
          setTimeout(() => this.hideError(), 5000);
          console.error('Chat: Error shown:', message);
        }

        hideError() {
          this.errorToast.classList.add('hidden');
        }

        updateTextEditor(content) {
          // Find the formatted editor element
          const formattedEditor = document.getElementById('formattedEditor');
          if (!formattedEditor) {
            console.warn('Chat: Formatted editor not found, skipping editor update');
            return;
          }

          // Check if the editor panel is currently visible
          const editorPanel = document.getElementById('editor-pane');
          if (!editorPanel || editorPanel.classList.contains('hidden')) {
            console.log('Chat: Editor panel not visible, skipping editor update');
            return;
          }

          // Validate content
          if (!content || typeof content !== 'string') {
            console.warn('Chat: Invalid content for text editor update', content);
            return;
          }

          // Store raw content for copy/download functionality
          this.rawEditorContent = content;
          console.log('Raw editor content updated:', content.substring(0, 100) + '...');

          try {
            // Configure marked.js options for security and formatting
            if (typeof marked !== 'undefined') {
              marked.setOptions({
                breaks: true,        // Convert line breaks to <br>
                gfm: true,          // GitHub Flavored Markdown
                headerIds: false,   // Disable header IDs for security
                mangle: false,      // Don't mangle email addresses
                sanitize: false,    // We'll use DOMPurify for sanitization
              });
            }

            // Convert Markdown to HTML
            let htmlContent = '';
            if (typeof marked !== 'undefined') {
              htmlContent = marked.parse(content);
            } else {
              // Fallback to plain text with preserved line breaks
              console.warn('Chat: marked.js not available, using plaintext fallback');
              htmlContent = content
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/\n/g, '<br>');
            }

            // Sanitize the HTML output
            let sanitizedHtml = '';
            if (typeof DOMPurify !== 'undefined') {
              sanitizedHtml = DOMPurify.sanitize(htmlContent, {
                ALLOWED_TAGS: ['h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'p', 'br', 'strong', 'em', 'u', 'ul', 'ol', 'li', 'blockquote', 'code', 'pre', 'a', 'table', 'thead', 'tbody', 'tr', 'th', 'td', 'hr', 'del', 'ins'],
                ALLOWED_ATTR: ['href', 'target', 'rel', 'class'],
                ALLOW_DATA_ATTR: false,
                ADD_ATTR: ['target', 'rel'],
                FORBID_TAGS: ['script', 'style', 'iframe', 'object', 'embed', 'form', 'input'],
                FORBID_ATTR: ['onerror', 'onload', 'onclick', 'onmouseover', 'style']
              });

              // Ensure all links open in new tabs with security attributes
              sanitizedHtml = sanitizedHtml.replace(/<a\s+href=/g, '<a target="_blank" rel="noopener noreferrer" href=');
            } else {
              // Fallback without sanitization (not recommended for production)
              console.warn('Chat: DOMPurify not available, content not sanitized');
              sanitizedHtml = htmlContent;
            }

            // Don't update if content is empty after processing
            if (!sanitizedHtml.trim()) {
              console.log('Chat: Content is empty after processing, skipping editor update');
              return;
            }

            // Update the formatted editor content (overwrite completely)
            formattedEditor.innerHTML = sanitizedHtml;

            // Scroll to top to show new content
            formattedEditor.scrollTop = 0;

            console.log('Chat: Formatted editor updated with AI response content');
          } catch (error) {
            console.error('Chat: Error updating formatted editor:', error);

            // Fallback to plain text display
            try {
              const fallbackContent = content
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/\n/g, '<br>');

              formattedEditor.innerHTML = `<p class="text-gray-300">${fallbackContent}</p>`;
              formattedEditor.scrollTop = 0;

              console.log('Chat: Used fallback rendering for editor content');
            } catch (fallbackError) {
              console.error('Chat: Fallback rendering also failed:', fallbackError);
            }
          }
        }

        saveMessages() {
          try {
            sessionStorage.setItem('chat-messages', JSON.stringify({
              messages: this.messages,
              counter: this.messageCounter,
              lastScrollPosition: this.transcript.scrollTop
            }));
          } catch (error) {
            console.warn('Chat: Could not save messages to session storage:', error);
          }
        }

        loadMessages() {
          try {
            const saved = sessionStorage.getItem('chat-messages');
            if (saved) {
              const data = JSON.parse(saved);
              this.messages = data.messages.map(msg => ({
                ...msg,
                timestamp: new Date(msg.timestamp)
              }));
              this.messageCounter = data.counter || 0;

              // Render existing messages
              this.messages.forEach(message => {
                this.renderMessage(message);
              });

              console.log(`Chat: Loaded ${this.messages.length} messages from session storage`);

              // Update text editor with the most recent AI response
              const lastAiMessage = this.messages
                .slice()
                .reverse()
                .find(msg => msg.role === 'ai');

              if (lastAiMessage) {
                this.updateTextEditor(lastAiMessage.content);
                console.log('Chat: Text editor updated with most recent AI response');
              }

              // Restore scroll position or scroll to bottom
              const savedScrollPosition = data.lastScrollPosition;
              setTimeout(() => {
                if (savedScrollPosition && savedScrollPosition > 0) {
                  this.transcript.scrollTop = savedScrollPosition;
                  this.checkScrollPosition();
                  console.log('Chat: Restored scroll position');
                } else {
                  this.scrollToBottom(false);
                  console.log('Chat: Scrolled to bottom after loading messages');
                }
              }, 150);
            }
          } catch (error) {
            console.warn('Chat: Could not load messages from session storage:', error);
          }
        }

        // Method to handle tab switching/visibility changes
        handleVisibilityChange() {
          if (!document.hidden) {
            // Page became visible again
            this.checkScrollPosition();
            console.log('Chat: Page became visible, scroll position checked');
          } else {
            // Page became hidden, save current state
            this.saveMessages();
            console.log('Chat: Page hidden, state saved');
          }
        }
      }

      // Initialize chat when DOM is ready
      document.addEventListener('DOMContentLoaded', () => {
        // Only initialize if we're on a page with the chat assistant
        if (document.getElementById('chat-transcript')) {
          window.chatManager = new ChatManager();

          // Handle visibility changes for tab switching
          document.addEventListener('visibilitychange', () => {
            if (window.chatManager) {
              window.chatManager.handleVisibilityChange();
            }
          });
        }
      });

      // Initialize immediately if DOM is already ready
      if (document.readyState === 'loading') {
        // DOM not ready, wait for DOMContentLoaded
      } else {
        // DOM is ready
        if (document.getElementById('chat-transcript')) {
          window.chatManager = new ChatManager();

          // Handle visibility changes for tab switching
          document.addEventListener('visibilitychange', () => {
            if (window.chatManager) {
              window.chatManager.handleVisibilityChange();
            }
          });
        }
      }
    })();
  </script>

  <!-- Markdown Editor Initialization -->
  <script>
    // Initialize markdown formatting once libraries are loaded
    document.addEventListener('DOMContentLoaded', function () {
      // Check if required libraries are available
      const hasMarked = typeof marked !== 'undefined';
      const hasDOMPurify = typeof DOMPurify !== 'undefined';

      console.log('Markdown Libraries Status:', {
        marked: hasMarked,
        DOMPurify: hasDOMPurify
      });

      if (!hasMarked) {
        console.warn('marked.js not loaded - markdown rendering will use plaintext fallback');
      }

      if (!hasDOMPurify) {
        console.warn('DOMPurify not loaded - HTML sanitization may be limited');
      }

      // Set global flag for formatted editor availability
      window.formattedEditorAvailable = true;

      // Initialize formatted editor with welcome message if no AI responses yet
      const formattedEditor = document.getElementById('formattedEditor');
      if (formattedEditor) {
        console.log('Formatted editor initialized and ready for AI responses');
      }
    });
  </script>

  <!-- Editor Actions Functionality -->
  <script>
    document.addEventListener('DOMContentLoaded', function () {
      // Initialize editor action handlers
      function initializeEditorActions() {
        const editorActions = document.querySelector('[data-editor-actions]');
        if (!editorActions) return;

        // Handle click events on editor action buttons
        editorActions.addEventListener('click', function (e) {
          console.log('Editor actions click event:', e.target);
          const button = e.target.closest('[data-action]');
          if (!button) {
            console.log('No button with data-action found');
            return;
          }

          const action = button.getAttribute('data-action');
          const editorElement = button.closest('[data-editor]');
          const editorId = editorElement ? editorElement.getAttribute('data-editor') : null;

          console.log('Action:', action, 'EditorId:', editorId);

          handleEditorAction(action, editorId);
        });
      }

      // Handle individual editor actions
      function handleEditorAction(action, editorId) {
        switch (action) {
          case 'copy':
            copyEditorContent(editorId);
            break;
          case 'download':
            downloadEditorContent(editorId);
            break;
          default:
            console.warn('Unknown editor action:', action);
        }
      }

      // Copy editor content to clipboard
      function copyEditorContent(editorId) {
        let content = '';

        if (window.chatManager && window.chatManager.rawEditorContent) {
          // Use raw Markdown content from chat manager
          content = window.chatManager.rawEditorContent;
        } else {
          // Fallback: get text content from the editor
          const editor = document.getElementById(editorId);
          if (editor) {
            content = editor.innerText || editor.textContent || '';
          }
        }

        if (!content.trim()) {
          showToast('No content to copy', 'warning');
          return;
        }

        // Use modern Clipboard API if available
        if (navigator.clipboard && window.isSecureContext) {
          navigator.clipboard.writeText(content)
            .then(() => {
              showToast('Content copied to clipboard!', 'success');
            })
            .catch((error) => {
              console.error('Failed to copy with Clipboard API:', error);
              fallbackCopyContent(content);
            });
        } else {
          // Fallback for older browsers or non-secure contexts
          fallbackCopyContent(content);
        }
      }

      // Fallback copy method using temporary textarea
      function fallbackCopyContent(content) {
        try {
          const textarea = document.createElement('textarea');
          textarea.value = content;
          textarea.style.position = 'fixed';
          textarea.style.top = '-9999px';
          textarea.style.left = '-9999px';
          document.body.appendChild(textarea);

          textarea.select();
          textarea.setSelectionRange(0, 99999); // For mobile devices

          const successful = document.execCommand('copy');
          document.body.removeChild(textarea);

          if (successful) {
            showToast('Content copied to clipboard!', 'success');
          } else {
            showToast('Failed to copy content', 'error');
          }
        } catch (error) {
          console.error('Fallback copy failed:', error);
          showToast('Failed to copy content', 'error');
        }
      }

      // Download editor content as a file
      function downloadEditorContent(editorId) {
        console.log('Download function called with editorId:', editorId);

        let content = '';
        let filename = 'ai-response.txt';

        console.log('Checking chatManager:', window.chatManager);
        console.log('Raw editor content:', window.chatManager?.rawEditorContent);

        if (window.chatManager && window.chatManager.rawEditorContent) {
          // Use raw Markdown content from chat manager
          content = window.chatManager.rawEditorContent;
          filename = 'ai-response.txt';
          console.log('Using raw content from chatManager:', content.substring(0, 100) + '...');
        } else {
          // Fallback: get text content from the editor
          const editor = document.getElementById(editorId);
          if (editor) {
            content = editor.innerText || editor.textContent || '';
            filename = 'editor-content.txt';
            console.log('Using fallback content from editor:', content.substring(0, 100) + '...');
          } else {
            console.log('No editor found with ID:', editorId);
          }
        }

        if (!content.trim()) {
          console.log('No content to download');
          showToast('No content to download. Please chat with the AI assistant first to generate content.', 'warning');
          return;
        }

        try {
          console.log('Creating download with filename:', filename);
          console.log('Content length:', content.length);

          // Create blob with content
          const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });
          console.log('Blob created successfully, size:', blob.size);

          // Create download link
          const link = document.createElement('a');
          const url = URL.createObjectURL(blob);
          link.href = url;
          link.download = filename;
          link.style.display = 'none'; // Hide the link

          console.log('Download link created with URL:', url);

          // Trigger download
          document.body.appendChild(link);
          console.log('Link added to body');

          link.click();
          console.log('Link clicked');

          // Clean up after a short delay
          setTimeout(() => {
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
            console.log('Link removed and URL revoked');
          }, 100);

          showToast('Content downloaded successfully!', 'success');
        } catch (error) {
          console.error('Failed to download content:', error);
          showToast('Failed to download content', 'error');
        }
      }

      // Show toast notification
      function showToast(message, type = 'info') {
        // Remove any existing toast
        const existingToast = document.querySelector('.toast');
        if (existingToast) {
          existingToast.remove();
        }

        // Create toast element
        const toast = document.createElement('div');
        toast.className = `toast toast-${type}`;
        toast.textContent = message;

        // Add to document
        document.body.appendChild(toast);

        // Show toast with animation
        setTimeout(() => {
          toast.classList.add('show');
        }, 100);

        // Hide and remove toast after delay
        setTimeout(() => {
          toast.classList.remove('show');
          setTimeout(() => {
            if (toast.parentNode) {
              toast.parentNode.removeChild(toast);
            }
          }, 300);
        }, 3000);
      }

      // Initialize when DOM is ready
      initializeEditorActions();
    });
  </script>

  <!-- React TypeScript Background Bundle -->
  <script src="static/js/bundle.js" defer></script>
</body>

</html>